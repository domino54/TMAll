/**
 * @name PlayerModels_Server.Script.txt
 * @author domino54
 * @version 2024-10-05
 */

#Const Version      "2024-10-05"
#Const ScriptName   "Libs/domino54/PlayerModels_Server.Script.txt"

#Include "TextLib" as TL
#Include "Libs/Nadeo/Log.Script.txt" as Log
#Include "Libs/domino54/CustomSkins_Players.Script.txt" as CSPlayers
#Include "Libs/domino54/Openplanet_Players.Script.txt" as OPPlayers
#Include "Libs/domino54/PlayerModels_Data.Script.txt" as PMData

// ---------------------------------- //
// Constants
// ---------------------------------- //

#Const C_LoadingMode_Compatibility    0   ///< Never loads archetypes or custom items. Replaces all paths with "DefaultPlayerModel".
#Const C_LoadingMode_LoadEverything   1   ///< Loads all archetypes and custom items normally.
#Const C_LoadingMode_AllowArchetypes  2   ///< Same as Compatibility, but allows archetypes to load.

/// These environments restrict the assignable archetypes and require unlock via items.
#Const C_LibPlayerModels_EnvironmentRequiresUnlock ["Stadium"]

/// These archetypes are available without the need of an unlock.
#Const C_LibPlayerModels_VehicleIgnoresUnlock ["StadiumCar"]

/// Model name, which references whatever model is used on the loaded map.
#Const C_LibPlayerModels_DefaultPlayerModel "DefaultPlayerModel"

// ---------------------------------- //
// Structs
// ---------------------------------- //

#Struct K_Options {
  /**
   * As soon as the game mode loads any items, they will be referenced in the saved replays.
   * This will cause a TON of item references, and make the replays unplayable outside of the title pack.
   * Custom items should load only in game modes, where players can spawn as different models on the same map.
   *
   * Therefore, the compatibility mode will not load any items or archetypes from the actual paths of the source files.
   *
   * Instead, all item paths are replaced with "DefaultPlayerModel", which references the current map model.
   * This model dynamically changes with the current map, but also locks the mode into a single model only.
   */
  Integer LoadingMode;

  /** Ignore model overlay in places, where they are irrelevant. */
  Boolean SkipOverlays;

  /** Load CarCommon skins to the first player model only. Use for skin selection interface. */
  Boolean CarCommonFirstModel;

  /** Player model ID allowlist for specific models to be loaded exclusively. */
  Text[] ModelIdAllowlist;

  /**
   * Model skin ID allowlist for specific skins to be loaded exclusively.
   * [SkinId => [ModelId]]
   */
  Text[][Text] SkinIdAllowlist;
}

// ---------------------------------- //
// Global variables
// ---------------------------------- //

declare K_Options G_LibPlayerModels_Options;

declare Text G_LibPlayerModels_CurrentMapEnvironmentName;
declare Text G_LibPlayerModels_CurrentMapPlayerModelName;
declare Text G_LibPlayerModels_CurrentMapPlayerModelId;

/// Lookup table for text-based model ID to loaded item Ident.
declare Ident[Text] G_LibPlayerModels_LoadedItemIdByLookupId;

// ---------------------------------- //
// Private functions
// ---------------------------------- //

Text Private_GetLookupId(Text _ModelId, Text _SkinId) {
  return """{{{_ModelId}}}:{{{_SkinId}}}""";
}

Text Private_GetLookupId(Text _ModelId, Boolean _IsArchetype) {
  if (_IsArchetype) {
    return """{{{_ModelId}}}:archetype""";
  }

  return _ModelId;
}

Text Private_GetLookupId(Text _ModelId) {
  return Private_GetLookupId(_ModelId, False);
}

Text Private_GetArchetypePath(Text _ItemPath) {
  if (G_LibPlayerModels_Options.LoadingMode == C_LoadingMode_Compatibility) {
    return C_LibPlayerModels_DefaultPlayerModel;
  }

  return _ItemPath;
}

Text Private_GetItemPath(Text _ItemPath) {
  if (G_LibPlayerModels_Options.LoadingMode != C_LoadingMode_LoadEverything) {
    return C_LibPlayerModels_DefaultPlayerModel;
  }

  return _ItemPath;
}

Boolean Private_IsModelAllowlisted(Text _ModelId) {
  return G_LibPlayerModels_Options.ModelIdAllowlist.count <= 0 || G_LibPlayerModels_Options.ModelIdAllowlist.exists(_ModelId);
}

Boolean Private_IsSkinAllowlisted(Text _SkinId, Text _ModelId) {
  if (G_LibPlayerModels_Options.SkinIdAllowlist.count <= 0) {
    return True;
  }

  if (_ModelId == "") {
    return G_LibPlayerModels_Options.SkinIdAllowlist.existskey(_SkinId);
  }

  return G_LibPlayerModels_Options.SkinIdAllowlist[_SkinId].exists(_ModelId);
}

Boolean Private_IsSkinAllowlisted(Text _SkinId) {
  return Private_IsSkinAllowlisted(_SkinId, "");
}

Ident Private_ItemListAdd(CMode _Context, Text[] _ItemProps) {
  declare ResultId = NullId;

  switch (_ItemProps.count) {
    case 1: ResultId = _Context.ItemList_Add(_ItemProps[0]);
    case 2: ResultId = _Context.ItemList_AddWithSkin(_ItemProps[0], _ItemProps[1]);
  }

  assert(ResultId != NullId, "Player model could not be loaded.");

  return ResultId;
}

Integer Private_LoadItems(CMode _Context, Text[][Text] _ItemsToLoad) {
  declare Ident[Text] CachedItemIds;

  foreach (ModelId => ItemProps in _ItemsToLoad) {
    declare ReusableIndex = TL::Join("*", ItemProps);

    // If we get the same [Model+Skin], don't load the same item twice, reuse an existing Ident.
    if (CachedItemIds.existskey(ReusableIndex)) {
      G_LibPlayerModels_LoadedItemIdByLookupId[ModelId] = CachedItemIds[ReusableIndex];
      continue;
    }

    declare ResultId = Private_ItemListAdd(_Context, ItemProps);
    CachedItemIds[ReusableIndex] = ResultId;
    G_LibPlayerModels_LoadedItemIdByLookupId[ModelId] = ResultId;
  }

  return CachedItemIds.count;
}

Void Private_LoadModelItems(CMode _Context) {
  // Dictionary of tuples. This is used later to call ItemList_Add.
  // [UniqueId => [ItemPath, SkinPath]]
  declare Text[][Text] ItemsToLoad = [];

  // Holds the item path for loading skins.
  declare Text[Text] BaseModelItemPath = [];

  // Prepare base player models.
  foreach (ModelId => Model in PMData::GetAllModels()) {
    if (!Private_IsModelAllowlisted(ModelId)) continue;

    declare AsItemId = Private_GetLookupId(ModelId);

    if (Model.LoadAs == PMData::C_LibPlayerModels_LoadAs_Archetype) {
      BaseModelItemPath[AsItemId] = Model.Archetype;
    } else {
      BaseModelItemPath[AsItemId] = Model.ItemPath;
    }

    if (Model.LoadAs == PMData::C_LibPlayerModels_LoadAs_ItemAndArchetype || Model.LoadAs == PMData::C_LibPlayerModels_LoadAs_Item) {
      ItemsToLoad[AsItemId] = [Private_GetItemPath(Model.ItemPath)];
    }

    if (Model.LoadAs == PMData::C_LibPlayerModels_LoadAs_ItemAndArchetype || Model.LoadAs == PMData::C_LibPlayerModels_LoadAs_Archetype) {
      declare AsArchetypeId = Private_GetLookupId(ModelId, True);

      ItemsToLoad[AsArchetypeId] = [Private_GetArchetypePath(Model.Archetype)];
    }
  }

  // Holds skin paths for loading overlays.
  declare Text[Text][Text] SkinsByBaseModelId = [];

  // Prepare skins.
  foreach (SkinId => Skin in PMData::GetAllSkins()) {
    if (!Private_IsSkinAllowlisted(SkinId)) continue;

    if (SkinsByBaseModelId.existskey(Skin.AppliesTo)) {
      SkinsByBaseModelId[Skin.AppliesTo][SkinId] = Skin.SkinPath;
    } else {
      SkinsByBaseModelId[Skin.AppliesTo] = [SkinId => Skin.SkinPath];
    }
  }

  // Load skins for base models.
  foreach (BaseModelId => Skins in SkinsByBaseModelId) {
    // Can't skip the skins in the loop above, because overlays may be allowed.
    if (!Private_IsModelAllowlisted(BaseModelId) && BaseModelId != PMData::C_LibPlayerModels_CarCommonWildcard) continue;

    foreach (SkinId => SkinPath in Skins) {
      // CarCommon wildcard: Load the skin for every base player model available.
      if (BaseModelId == PMData::C_LibPlayerModels_CarCommonWildcard) {
        foreach (ModelId => __ in BaseModelItemPath) {
          if (Private_IsSkinAllowlisted(SkinId, BaseModelId)) continue;

          declare LookupId = Private_GetLookupId(ModelId, SkinId);

          ItemsToLoad[LookupId] = [Private_GetItemPath(BaseModelItemPath[ModelId]), SkinPath];
        }
      }

      // Regular skin: Load for a single base player model.
      else {
        declare LookupId = Private_GetLookupId(BaseModelId, SkinId);

        ItemsToLoad[LookupId] = [Private_GetItemPath(BaseModelItemPath[BaseModelId]), SkinPath];
      }
    }
  }

  // Prepare overlays.
  foreach (ModelOverlayId => ModelOverlay in PMData::GetAllOverlays()) {
    if (G_LibPlayerModels_Options.SkipOverlays) break;
    if (!Private_IsModelAllowlisted(ModelOverlayId)) continue;

    declare BaseModelLookupId = Private_GetLookupId(ModelOverlayId);

    ItemsToLoad[BaseModelLookupId] = [Private_GetItemPath(ModelOverlay.ItemPath)];

    // Overlay is using the same skins as the overlay's base player model.
    if (SkinsByBaseModelId.existskey(ModelOverlay.Extends)) {
      foreach (SkinId => SkinPath in SkinsByBaseModelId[ModelOverlay.Extends]) {
        declare LookupId = Private_GetLookupId(ModelOverlayId, SkinId);

        ItemsToLoad[LookupId] = [Private_GetItemPath(ModelOverlay.ItemPath), SkinPath];
      }
    }

    // If there are any CarCommon skins, apply them to the overlay.
    if (SkinsByBaseModelId.existskey(PMData::C_LibPlayerModels_CarCommonWildcard)) {
      foreach (SkinId => SkinPath in SkinsByBaseModelId[PMData::C_LibPlayerModels_CarCommonWildcard]) {
        if (Private_IsSkinAllowlisted(SkinId, ModelOverlay.Extends)) continue;

        declare LookupId = Private_GetLookupId(ModelOverlayId, SkinId);

        ItemsToLoad[LookupId] = [Private_GetItemPath(ModelOverlay.ItemPath), SkinPath];
      }
    }
  }

  // Load items into the game mode.
  declare NbItems = Private_LoadItems(_Context, ItemsToLoad);

  Log::Log("""[PlayerModels_Server] Loaded {{{NbItems}}} items""");
}

Boolean Private_CurrentMapRequiresUnlock() {
  return C_LibPlayerModels_EnvironmentRequiresUnlock.exists(G_LibPlayerModels_CurrentMapEnvironmentName);
}

Ident Private_GetModelLookupId(Text _ModelId, Text _SkinId, Boolean _PreferCustom) {
  // If not specified to use custom items, try to match an archetype to preserve the regular skins.
  if (!_PreferCustom) {
    declare Archetype = Private_GetLookupId(_ModelId, True);

    if (G_LibPlayerModels_LoadedItemIdByLookupId.existskey(Archetype)) {
      return G_LibPlayerModels_LoadedItemIdByLookupId[Archetype];
    }
  }

  // If a skin ID is specified, try to load the item with it.
  if (_SkinId != "") {
    declare WithSkin = Private_GetLookupId(_ModelId, _SkinId);

    if (G_LibPlayerModels_LoadedItemIdByLookupId.existskey(WithSkin)) {
      return G_LibPlayerModels_LoadedItemIdByLookupId[WithSkin];
    }
  }

  // Load the item with a basic skin.
  declare Item = Private_GetLookupId(_ModelId);

  if (G_LibPlayerModels_LoadedItemIdByLookupId.existskey(Item)) {
    return G_LibPlayerModels_LoadedItemIdByLookupId[Item];
  }

  // Nothing was found, fallback to no custom model.
  return NullId;
}

Void Private_AssignModel(CPlayer _Player, Ident _ItemId) {
  switchtype (_Player) {
    case CSmPlayer: {
      (_Player as CSmPlayer).ForceModelId = _ItemId;
    }
    case CTmPlayer: {
      (_Player as CTmPlayer).ForceModelId = _ItemId;
    }
    default: {
      assert(False, "Attempted to assign player model to unsupported player class instance.");
    }
  }
}

Void Private_AssignModel(CPlayer _Player, Text _ModelId, Text _SkinId, Boolean _PreferCustom) {
  declare ModelId = PMData::ResolveModelId(_ModelId);
  declare ItemId = Private_GetModelLookupId(ModelId, _SkinId, _PreferCustom);

  Private_AssignModel(_Player, ItemId);
}

// ---------------------------------- //
// Public functions
// ---------------------------------- //

Void Unload(CMode _Context) {
  G_LibPlayerModels_Options = K_Options {};
  G_LibPlayerModels_LoadedItemIdByLookupId.clear();
}

Void Load(CMode _Context, K_Options _Options) {
  Unload(_Context);

  G_LibPlayerModels_Options = _Options;

  Private_LoadModelItems(_Context);
}

Void Load(CMode _Context) {
  Load(_Context, K_Options {});
}

Void SetMapProperties(Text _Environment, Text _MapPlayerModelName) {
  G_LibPlayerModels_CurrentMapEnvironmentName = _Environment;
  G_LibPlayerModels_CurrentMapPlayerModelName = _MapPlayerModelName;
  G_LibPlayerModels_CurrentMapPlayerModelId = PMData::ResolveModelId(_MapPlayerModelName);
}

Text GetMapPlayerModelId() {
  return G_LibPlayerModels_CurrentMapPlayerModelId;
}

/**
 * Pick a random skin for the player and remember it until they leave.
 */
Text GetPlayerRandomizedSkinId(CUser _User, Text _ModelId) {
  declare Text[Text] LibPlayerModels_RandomizedSkins for _User;

  // Preference not set, and there's already a random skin assigned.
  if (LibPlayerModels_RandomizedSkins.existskey(_ModelId)) {
    return LibPlayerModels_RandomizedSkins[_ModelId];
  }

  // Pick a random skin and keep it on the server side.
  declare SkinId = PMData::GetRandomSkinIdByModelId(_ModelId, False);

  if (SkinId != "") {
    LibPlayerModels_RandomizedSkins[_ModelId] = SkinId;
  }

  return SkinId;
}

/**
 * Get the player skin preference or a randomixed skin.
 */
Text GetPlayerSkinId(CUser _User, Text _ModelId) {
  declare BaseModelId = PMData::GetBaseModelId(_ModelId);
  declare PlayerPreferenceId = CSPlayers::GetPlayerSkinId(_User.Login, BaseModelId);

  // Return the preference if it is set.
  if (PlayerPreferenceId != "") {
    return PlayerPreferenceId;
  }

  return GetPlayerRandomizedSkinId(_User, BaseModelId);
}

/**
 * @returns List of all skin IDs the local player has got assigned.
 */
Text[][Text] GetLocalPlayerSkinIds() {
  declare Text[][Text] Result;

  // Users array exists in both game modes and maptypes.
  foreach (User in Users) {
    foreach (BaseModelId => __ in PMData::GetAllModels()) {
      declare PlayerPreferenceId = GetPlayerSkinId(User, BaseModelId);
      if (PlayerPreferenceId == "") continue;

      if (Result.existskey(PlayerPreferenceId)) {
        Result[PlayerPreferenceId].add(BaseModelId);
      } else {
        Result[PlayerPreferenceId] = [BaseModelId];
      }
    }
  }

  return Result;
}

/**
 * Check if a model requires special unlock.
 */
Boolean GetModelRequiresUnlock(Text _ModelId) {
  declare Archetype = PMData::GetModelArchetype(_ModelId);

  return !C_LibPlayerModels_VehicleIgnoresUnlock.exists(Archetype);
}

/**
 * Check if the player requires additional special unlock to assign the model.
 */
Boolean GetPlayerRequiresUnlock(Text _Login) {
  //return !OPPlayers::HasOpenplanet(_Login);
  return True;
}

/**
 * Check if the player model should override an archetype.
 */
Boolean GetPlayerPreferCustom(Text _Login, Text _ModelId) {
  if (CSPlayers::GetPlayerUseCustomOverArchetype(_Login, _ModelId)) {
    return True;
  }

  return Private_CurrentMapRequiresUnlock() && GetPlayerRequiresUnlock(_Login) && GetModelRequiresUnlock(_ModelId);
}

/**
 * Assign a model to a player.
 */
Void AssignModel(CPlayer _Player, Text _ModelId, Text _SkinId, Boolean _PreferCustom) {
  Private_AssignModel(_Player, _ModelId, _SkinId, _PreferCustom);
}

/**
 * Assign a model to a player (automatic skin).
 */
Void AssignModel(CPlayer _Player, Text _ModelId, Boolean _PreferCustom) {
  declare SkinId = GetPlayerSkinId(_Player.User, _ModelId);

  AssignModel(_Player, _ModelId, SkinId, _PreferCustom);
}

/**
 * Assign a model to a player (automatic prefer custom).
 */
Void AssignModel(CPlayer _Player, Text _ModelId, Text _SkinId) {
  declare PreferCustom = GetPlayerPreferCustom(_Player.User.Login, _ModelId);

  AssignModel(_Player, _ModelId, _SkinId, PreferCustom);
}

/**
 * Assign a model to a player (automatic skin, prefer custom).
 */
Void AssignModel(CPlayer _Player, Text _ModelId) {
  declare PreferCustom = GetPlayerPreferCustom(_Player.User.Login, _ModelId);

  AssignModel(_Player, _ModelId, PreferCustom);
}

/**
 * Assign a model to a player (automatic model from current map, skin, prefer custom).
 */
Void AssignModel(CPlayer _Player) {
  AssignModel(_Player, G_LibPlayerModels_CurrentMapPlayerModelId);
}
