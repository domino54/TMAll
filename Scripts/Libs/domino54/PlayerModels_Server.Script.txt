/**
 * @name PlayerModels_Server.Script.txt
 * @author domino54
 * @version 2024-07-17
 */

#Const Version      "2024-07-17"
#Const ScriptName   "Libs/domino54/PlayerModels_Server.Script.txt"

#Include "Libs/Nadeo/Log.Script.txt" as Log
#Include "Libs/domino54/CustomSkins_Players.Script.txt" as CSPlayers
#Include "Libs/domino54/Openplanet_Players.Script.txt" as OPPlayers
#Include "Libs/domino54/PlayerModels_Data.Script.txt" as PMData

// ---------------------------------- //
// Constants
// ---------------------------------- //

#Const C_LibPlayerModels_CompatibilityMode_Disabled         0   ///< Loads items and archetypes normally.
#Const C_LibPlayerModels_CompatibilityMode_Strict           1   ///< Never loads items or archetypes, only loads skins onto the player map model.
#Const C_LibPlayerModels_CompatibilityMode_AllowArchetypes  2   ///< Same as Strict, but allows archetypes to load.

/// These environments restrict the assignable archetypes and require unlock via items.
#Const C_LibPlayerModels_EnvironmentRequiresUnlock ["Stadium"]

/// These archetypes are available without the need of an unlock.
#Const C_LibPlayerModels_VehicleIgnoresUnlock ["StadiumCar"]

/// Model name, which references whatever model is used on the loaded map.
#Const C_LibPlayerModels_DefaultPlayerModel "DefaultPlayerModel"

// ---------------------------------- //
// Global variables
// ---------------------------------- //

declare Text G_LibPlayerModels_CurrentMapEnvironmentName;
declare Text G_LibPlayerModels_CurrentMapPlayerModelName;
declare Text G_LibPlayerModels_CurrentMapPlayerModelId;

/**
 * As soon as the game mode loads any items, they will be referenced in the saved replays.
 * This can cause a TON of rererences and make the replays unplayable outside of the title pack.
 * Custom items should load only in game modes, where players can spawn as different mdoels on the same map.
 *
 * Therefore, the compatibility mode will not load any items or archetypes from the actual paths of the source files.
 *
 * Instead, all item paths are replaced with "DefaultPlayerModel", which references the current map model.
 * This model dynamically changes with the current map, but also locks the mode into a single model only.
 */
declare Integer G_LibPlayerModels_CompatibilityMode;

/// Lookup table for text-based model ID to loaded item Ident.
declare Ident[Text] G_LibPlayerModels_LoadedItemIdByLookupId;

/// Lookup ID allowlist for specific models to be loaded exclusively.
declare Text[] G_LibPlayerModels_PlayerModelIdAllowlist;

// ---------------------------------- //
// Private functions
// ---------------------------------- //

Text Private_GetLookupId(Text _ModelId, Text _SkinId) {
  return """{{{_ModelId}}}:{{{_SkinId}}}""";
}

Text Private_GetLookupId(Text _ModelId, Boolean _IsArchetype) {
  if (_IsArchetype) {
    return """{{{_ModelId}}}:archetype""";
  }

  return _ModelId;
}

Text Private_GetLookupId(Text _ModelId) {
  return Private_GetLookupId(_ModelId, False);
}

Text Private_GetArchetypePath(Text _ItemPath) {
  if (G_LibPlayerModels_CompatibilityMode == C_LibPlayerModels_CompatibilityMode_Strict) {
    return C_LibPlayerModels_DefaultPlayerModel;
  }

  return _ItemPath;
}

Text Private_GetItemPath(Text _ItemPath) {
  if (G_LibPlayerModels_CompatibilityMode != C_LibPlayerModels_CompatibilityMode_Disabled) {
    return C_LibPlayerModels_DefaultPlayerModel;
  }

  return _ItemPath;
}

Boolean Private_GetIsAllowlisted(Text _ModelId) {
  return G_LibPlayerModels_PlayerModelIdAllowlist.count <= 0 || G_LibPlayerModels_PlayerModelIdAllowlist.exists(_ModelId);
}

Void Private_LoadPlayerModelItems(CMode _Context, Text[] _Allowlist) {
  G_LibPlayerModels_PlayerModelIdAllowlist = _Allowlist;

  // Dictionary of tuples. This is used later to call ItemList_Add.
  // [UniqueId => [ItemPath, SkinPath]]
  declare Text[][Text] ItemsToLoad = [];

  // Holds the item path for loading skins.
  declare Text[Text] BaseModelItemPath = [];

  // Prepare base player models.
  foreach (PlayerModelId => PlayerModel in PMData::GetAllPlayerModels()) {
    if (!Private_GetIsAllowlisted(PlayerModelId)) continue; 

    declare AsItemId = Private_GetLookupId(PlayerModelId);

    BaseModelItemPath[AsItemId] = PlayerModel.ItemPath;

    if (PlayerModel.LoadAs == PMData::C_LibPlayerModels_LoadAs_ItemAndArchetype || PlayerModel.LoadAs == PMData::C_LibPlayerModels_LoadAs_Item) {
        ItemsToLoad[AsItemId] = [Private_GetItemPath(PlayerModel.ItemPath)];
    }

    if (PlayerModel.LoadAs == PMData::C_LibPlayerModels_LoadAs_ItemAndArchetype || PlayerModel.LoadAs == PMData::C_LibPlayerModels_LoadAs_Archetype) {
      declare AsArchetypeId = Private_GetLookupId(PlayerModelId, True);

      ItemsToLoad[AsArchetypeId] = [Private_GetArchetypePath(PlayerModel.Archetype)];
    }
  }

  // Holds skin paths for loading overlays.
  declare Text[Text][Text] SkinsByBaseModelId = [];

  // Prepare skins.
  foreach (ModelSkinId => ModelSkin in PMData::GetAllModelSkins()) {
    // Skins flagged by IsDefault are fake and used only as a display of the base player model appearance.
    if (ModelSkin.IsDefault) {
      continue;
    }

    if (SkinsByBaseModelId.existskey(ModelSkin.AppliesTo)) {
      SkinsByBaseModelId[ModelSkin.AppliesTo][ModelSkinId] = ModelSkin.SkinPath;
    } else {
      SkinsByBaseModelId[ModelSkin.AppliesTo] = [ModelSkinId => ModelSkin.SkinPath];
    }
  }

  // Load skins for base models.
  foreach (BaseModelId => Skins in SkinsByBaseModelId) {
    if (!Private_GetIsAllowlisted(BaseModelId)) continue;

    foreach (ModelSkinId => SkinPath in Skins) {
      // CarCommon wildcard: Load the skin for every base player model available.
      if (BaseModelId == PMData::C_LibPlayerModels_CarCommonWildcard) {
        foreach (ModelId => __ in BaseModelItemPath) {
          declare LookupId = Private_GetLookupId(ModelId, ModelSkinId);

          ItemsToLoad[LookupId] = [Private_GetItemPath(BaseModelItemPath[ModelId]), SkinPath];
        }
      }

      // Regular skin: Load for a single base player model.
      else {
        declare LookupId = Private_GetLookupId(BaseModelId, ModelSkinId);

        ItemsToLoad[LookupId] = [Private_GetItemPath(BaseModelItemPath[BaseModelId]), SkinPath];
      }
    }
  }

  // Prepare overlays.
  foreach (ModelOverlayId => ModelOverlay in PMData::GetAllModelOverlays()) {
    if (!Private_GetIsAllowlisted(ModelOverlayId)) continue;

    declare BaseModelLookupId = Private_GetLookupId(ModelOverlayId);

    ItemsToLoad[BaseModelLookupId] = [Private_GetItemPath(ModelOverlay.ItemPath)];

    // Overlay is using the same skins as the overlay's base player model.
    if (SkinsByBaseModelId.existskey(ModelOverlay.Extends)) {
      foreach (ModelSkinId => SkinPath in SkinsByBaseModelId[ModelOverlay.Extends]) {
        declare LookupId = Private_GetLookupId(ModelOverlayId, ModelSkinId);

        ItemsToLoad[LookupId] = [Private_GetItemPath(ModelOverlay.ItemPath), SkinPath];
      }
    }

    // If there are any CarCommon skins, apply them to the overlay.
    if (SkinsByBaseModelId.existskey(PMData::C_LibPlayerModels_CarCommonWildcard)) {
      foreach (ModelSkinId => SkinPath in SkinsByBaseModelId[PMData::C_LibPlayerModels_CarCommonWildcard]) {
        declare LookupId = Private_GetLookupId(ModelOverlayId, ModelSkinId);

        ItemsToLoad[LookupId] = [Private_GetItemPath(ModelOverlay.ItemPath), SkinPath];
      }
    }
  }

  // Load items into the game mode.
  foreach (PlayerModelId => ItemProps in ItemsToLoad) {
    switch (ItemProps.count) {
      case 1: G_LibPlayerModels_LoadedItemIdByLookupId[PlayerModelId] = _Context.ItemList_Add(ItemProps[0]);
      case 2: G_LibPlayerModels_LoadedItemIdByLookupId[PlayerModelId] = _Context.ItemList_AddWithSkin(ItemProps[0], ItemProps[1]);
      default: assert(False, "Player model specified in an incorrect format.");
    }
  }

  declare NbItems = G_LibPlayerModels_LoadedItemIdByLookupId.count;

  Log::Log("""[PlayerModels_Server] Loaded {{{NbItems}}} items""");
}

Boolean Private_CurrentMapRequiresUnlock() {
  return C_LibPlayerModels_EnvironmentRequiresUnlock.exists(G_LibPlayerModels_CurrentMapEnvironmentName);
}

Ident Private_GetPlayerModelLookupId(Text _ModelId, Text _SkinId, Boolean _PreferCustom) {
  // If not specified to use custom items, try to match an archetype to preserve the regular skins.
  if (!_PreferCustom) {
    declare Archetype = Private_GetLookupId(_ModelId, True);

    if (G_LibPlayerModels_LoadedItemIdByLookupId.existskey(Archetype)) {
      return G_LibPlayerModels_LoadedItemIdByLookupId[Archetype];
    }
  }

  // If a skin ID is specified, try to load the item with it.
  if (_SkinId != "") {
    declare WithSkin = Private_GetLookupId(_ModelId, _SkinId);

    if (G_LibPlayerModels_LoadedItemIdByLookupId.existskey(WithSkin)) {
      return G_LibPlayerModels_LoadedItemIdByLookupId[WithSkin];
    }
  }

  // Load the item with a basic skin.
  declare Item = Private_GetLookupId(_ModelId);

  if (G_LibPlayerModels_LoadedItemIdByLookupId.existskey(Item)) {
    return G_LibPlayerModels_LoadedItemIdByLookupId[Item];
  }

  // Nothing was found, fallback to no custom model.
  return NullId;
}

Void Private_AssignPlayerModel(CPlayer _Player, Ident _ModelId) {
  switchtype (_Player) {
    case CSmPlayer: {
      (_Player as CSmPlayer).ForceModelId = _ModelId;
    }
    case CTmPlayer: {
      (_Player as CTmPlayer).ForceModelId = _ModelId;
    }
    default: {
      assert(False, "Attempted to assign player model to unsupported player class instance.");
    }
  }
}

Void Private_AssignPlayerModel(CPlayer _Player, Text _ModelId, Text _SkinId, Boolean _PreferCustom) {
  declare ModelId = Private_GetPlayerModelLookupId(_ModelId, _SkinId, _PreferCustom);

  Private_AssignPlayerModel(_Player, ModelId);
}

// ---------------------------------- //
// Public functions
// ---------------------------------- //

Text GetScriptVersion() {
  return Version;
}

Text GetScriptName() {
  return ScriptName;
}

Void Unload(CMode _Context) {
  G_LibPlayerModels_LoadedItemIdByLookupId.clear();
  G_LibPlayerModels_PlayerModelIdAllowlist.clear();
}

Void DisableCompatibilityMode() {
  G_LibPlayerModels_CompatibilityMode = C_LibPlayerModels_CompatibilityMode_Disabled;
}

Void StrictCompatibilityMode() {
  G_LibPlayerModels_CompatibilityMode = C_LibPlayerModels_CompatibilityMode_Strict;
}

Void AllowArchetypesCompatibilityMode() {
  G_LibPlayerModels_CompatibilityMode = C_LibPlayerModels_CompatibilityMode_AllowArchetypes;
}

Void Load(CMode _Context, Text[] _Allowlist) {
  Private_LoadPlayerModelItems(_Context, _Allowlist);
}

Void Load(CMode _Context) {
  Load(_Context, []);
}

Void SetMapProperties(Text _Environment, Text _MapPlayerModelName) {
  G_LibPlayerModels_CurrentMapEnvironmentName = _Environment;
  G_LibPlayerModels_CurrentMapPlayerModelName = _MapPlayerModelName;
  G_LibPlayerModels_CurrentMapPlayerModelId = PMData::GetPlayerModelIdByItemPath(_MapPlayerModelName);
}

Text GetMapPlayerModelId() {
  return G_LibPlayerModels_CurrentMapPlayerModelId;
}

/**
 * Pick a random skin for the player and remember it until they leave.
 */
Text GetPlayerRandomizedSkinId(CPlayer _Player, Text _ModelId) {
  declare Text[Text] LibPlayerModels_RandomizedSkins for _Player;

  // Preference not set, and there's already a random skin assigned.
  if (LibPlayerModels_RandomizedSkins.existskey(_ModelId)) {
    return LibPlayerModels_RandomizedSkins[_ModelId];
  }

  // Pick a random skin and keep it on the server side.
  declare SkinId = PMData::GetRandomSkinIdByModelId(_ModelId, False);

  if (SkinId != "") {
    LibPlayerModels_RandomizedSkins[_ModelId] = SkinId;
  }

  return SkinId;
}

/**
 * Get the player skin preference or a randomixed skin.
 */
Text GetPlayerSkinId(CPlayer _Player, Text _ModelId) {
  declare BaseModelId = PMData::GetBasePlayerModelId(_ModelId);
  declare PlayerPreferenceId = CSPlayers::GetPlayerSkinId(_Player.User.Login, BaseModelId);

  // Return the preference if it is set.
  if (PlayerPreferenceId != "") {
    return PlayerPreferenceId;
  }

  return GetPlayerRandomizedSkinId(_Player, BaseModelId);
}

/**
 * Check if a model requires special unlock.
 */
Boolean GetPlayerModelRequiresUnlock(Text _ModelId) {
  declare Archetype = PMData::GetPlayerModelArchetype(_ModelId);

  return !C_LibPlayerModels_VehicleIgnoresUnlock.exists(Archetype);
}

/**
 * Check if the player requires additional special unlock to assign the model.
 */
Boolean GetPlayerRequiresUnlock(Text _Login) {
  return !OPPlayers::HasOpenplanet(_Login);
}

/**
 * Check if the player model should override an archetype.
 */
Boolean GetPlayerPreferCustom(Text _Login, Text _ModelId) {
  if (CSPlayers::GetPlayerUseCustomOverArchetype(_Login, _ModelId)) {
    return True;
  }

  return Private_CurrentMapRequiresUnlock() && GetPlayerRequiresUnlock(_Login) && GetPlayerModelRequiresUnlock(_ModelId);
}

/**
 * Assign a model to a player.
 */
Void AssignPlayerModel(CPlayer _Player, Text _ModelId, Text _SkinId, Boolean _PreferCustom) {
  Private_AssignPlayerModel(_Player, _ModelId, _SkinId, _PreferCustom);
}

/**
 * Assign a model to a player (automatic skin).
 */
Void AssignPlayerModel(CPlayer _Player, Text _ModelId, Boolean _PreferCustom) {
  declare SkinId = GetPlayerSkinId(_Player, _ModelId);

  AssignPlayerModel(_Player, _ModelId, SkinId, _PreferCustom);
}

/**
 * Assign a model to a player (automatic prefer custom).
 */
Void AssignPlayerModel(CPlayer _Player, Text _ModelId, Text _SkinId) {
  declare PreferCustom = GetPlayerPreferCustom(_Player.User.Login, _ModelId);

  AssignPlayerModel(_Player, _ModelId, _SkinId, PreferCustom);
}

/**
 * Assign a model to a player (automatic skin, prefer custom).
 */
Void AssignPlayerModel(CPlayer _Player, Text _ModelId) {
  declare PreferCustom = GetPlayerPreferCustom(_Player.User.Login, _ModelId);

  AssignPlayerModel(_Player, _ModelId, PreferCustom);
}

/**
 * Assign a model to a player (automatic model from current map, skin, prefer custom).
 */
Void AssignPlayerModel(CPlayer _Player) {
  AssignPlayerModel(_Player, G_LibPlayerModels_CurrentMapPlayerModelId);
}
