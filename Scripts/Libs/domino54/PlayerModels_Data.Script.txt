/**
 * @name PlayerModels_Data.Script.txt
 * @author domino54
 * @version 2024-10-05
 */

#Const Version      "2024-10-05"
#Const ScriptName   "Libs/domino54/PlayerModels_Data.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/Log.Script.txt" as Log
#Include "Libs/domino54/HttpClient.Script.txt" as HttpClient
#Include "Libs/domino54/PlayerModels_Structs.Script.txt" as Structs

// ---------------------------------- //
// Constants
// ---------------------------------- //

#Const C_LibPlayerModels_Namespace                "player_models"
#Const C_LibPlayerModels_EventId_GetIndexFile     "player_models:index"
#Const C_LibPlayerModels_EventId_GetSourceFile    "player_models:source"
#Const C_LibPlayerModels_DefaultIndexFileUrl      "file://Media/Data/PlayerModels/index.json"
#Const C_LibPlayerModels_ModelType_Character      "Character"
#Const C_LibPlayerModels_ModelType_Vehicle        "Vehicle"
#Const C_LibPlayerModels_LoadAs_Archetype         "Archetype"
#Const C_LibPlayerModels_LoadAs_Item              "Item"
#Const C_LibPlayerModels_LoadAs_ItemAndArchetype  "ItemAndArchetype"
#Const C_LibPlayerModels_CarCommonWildcard        "*"
#Const C_LibPlayerModels_CarCommonDirectory       "CarCommon\\"
#Const C_LibPlayerModels_UserSkinsDirectories     ["Models", "Vehicles"]
#Const C_LibPlayerModels_UserSkinsNamespace       "userdata"
#Const C_LibPlayerModels_RegexFileNameFull        "[^\\/\\\\]+$"
#Const C_LibPlayerModels_RegexItemName            "([^\\/\\\\]+)\\.Item\\.Gbx$"
#Const C_LibPlayerModels_RegexReplacedSlashes     "[\\/\\\\]"
#Const C_LibPlayerModels_RegexMatchUserSkinPath   "^[^\\\\]+\\\\(.+)\\\\([^\\\\]+)\\.zip$"
#Const C_LibPlayerModels_CharacterArchetypes      ["ArenaPlayer", "Minion"]
#Const C_LibPlayerModels_TMUnitedArchetypes       ["DesertCar", "SnowCar", "RallyCar", "IslandCar", "BayCar", "CoastCar", "StadiumCar"]

// ---------------------------------- //
// Structs
// ---------------------------------- //

#Struct Structs::K_Model as K_Model
#Struct Structs::K_Skin as K_Skin
#Struct Structs::K_Overlay as K_Overlay
#Struct Structs::K_GameplayInfo as K_GameplayInfo

#Struct K_Options {
  /** Override the default index file URL. */
  Text IndexFileUrl;

  /** URLs of additional source files to load. */
  Text[] ExtraSourceFilesUrls;

  /** Interpret the user's skin directory for custom skin selection purposes. */
  Boolean LoadUserSkinsDirectory;
}

/// An index file references paths to all data source files to load.
/// Ideally load them from subdirectories of file://Media/Data/PlayerModels/
#Struct K_IndexFile {
  Text[] SourceUrls;
  Text[] SortOverrides;
}

/// A source file describes gameplay models and skins applicable to them.
#Struct K_SourceFile {
  Text Id;
  K_Model[] Models;
  K_Skin[] Skins;
  K_Overlay[] Overlays;
}

// ---------------------------------- //
// Global variables
// ---------------------------------- //

declare K_Options G_LibPlayerModels_Options;

declare Integer G_LibPlayerModels_LoadingStartTime;
declare Text[] G_LibPlayerModels_SourceFilesOrder;
declare K_SourceFile[Text] G_LibPlayerModels_SourceFilesToProcess;
declare CTaskResult_FileList[Ident] G_LibPlayerModels_PendingTasks;
declare Text[] G_LibPlayerModels_SkinPathsToProcess;

declare Text G_LibPlayerModels_ModelTypeCategory;
declare Text[] G_LibPlayerModels_SortingOverrides;

declare K_Model[Text] G_LibPlayerModels_ModelById;
declare K_Skin[Text] G_LibPlayerModels_SkinById;
declare K_Overlay[Text] G_LibPlayerModels_OverlayById;

/// Stores the custom model id by the respective item path.
/// ["canyoncar" => "trackmania:canyoncar"]
/// ["vehicles/trafficcar.item.gbx" => "trackmania:trafficcar"]
/// ["valleycar4x" => "tmall:valleycar4x"]
declare Text[Text] G_LibPlayerModels_ModelIdByItemPath;
declare Text[Text] G_LibPlayerModels_ModelIdBySkinDirectory;

// ---------------------------------- //
// Private functions
// ---------------------------------- //

Void Private_Log(Text _Message) {
  Log::Log("""[PlayerModels_Data] {{{_Message}}}""");
}

Text Private_GetBaseUrl(Text _Url) {
  return TL::RegexReplace(C_LibPlayerModels_RegexFileNameFull, _Url, "i", "");
}

Boolean Private_IsRelativeUrl(Text _Value) {
  return TL::StartsWith("./", _Value) || TL::StartsWith(".\\", _Value);
}

/**
 * Glue a relative path to the base url.
 * Assumes that `_RelativePath` starts with "./" as the first 2 characters are skipped.
 */
Text Private_FromBaseUrl(Text _BaseUrl, Text _RelativePath) {
  return _BaseUrl ^ TL::SubString(_RelativePath, 2, TL::Length(_RelativePath) - 2);
}

/**
 * Normalizes the item path to a simplified string.
 * This name is used later to look up the custom model id.
 *
 * `StadiumCar` -> `stadiumcar`
 * `CanyonCar.Item.Gbx` -> `canyoncar`
 * `Vehicles/IslandCar.Item.Gbx` -> `islandcar`
 */
Text Private_NormalizeItemName(Text _ItemPath) {
  declare Match = TL::RegexMatch(C_LibPlayerModels_RegexItemName, _ItemPath, "i");

  if (Match.count < 2 || Match[1] == "") {
    return TL::ToLowerCase(_ItemPath);
  }

  return TL::ToLowerCase(Match[1]);
}

/**
 * Normalizes the item path to a simplified path.
 * @example `Vehicles\\CanyonCar.Item.Gbx` -> `vehicles/canyoncar.item.gbx`
 */
Text Private_NormalizeItemPath(Text _ItemPath) {
  return TL::ToLowerCase(TL::RegexReplace(C_LibPlayerModels_RegexReplacedSlashes, _ItemPath, "i", "/"));
}

/**
 * Check if an archetype is a character.
 */
Boolean Private_IsCharacter(Text _Archetype) {
  return C_LibPlayerModels_CharacterArchetypes.exists(_Archetype);
}

/**
 * Load the metadata from the previously downloaded index file.
 */
Void Private_LoadIndexFileJson(Text _Body) {
  if (_Body == "") {
    return;
  }

  declare K_IndexFile IndexFile;
  declare Copied = IndexFile.fromjson(_Body);

  G_LibPlayerModels_SortingOverrides = IndexFile.SortOverrides;

  // These are added on top of everything, if the game mode wants to load extra models.
  foreach (ExtraSourceUrl in G_LibPlayerModels_Options.ExtraSourceFilesUrls) {
    IndexFile.SourceUrls.add(ExtraSourceUrl);
  }

  G_LibPlayerModels_SourceFilesOrder.clear();

  declare BaseUrl = Private_GetBaseUrl(G_LibPlayerModels_Options.IndexFileUrl);

  foreach (RawSourceUrl in IndexFile.SourceUrls) {
    declare SourceUrl = RawSourceUrl;

    if (Private_IsRelativeUrl(SourceUrl)) {
      SourceUrl = Private_FromBaseUrl(BaseUrl, SourceUrl);
    }

    if (!HttpClient::IsValidUrl(SourceUrl)) {
      continue;
    }

    // Is later used to apply models in the correct order from the index file.
    G_LibPlayerModels_SourceFilesOrder.add(SourceUrl);

    HttpClient::Get(C_LibPlayerModels_EventId_GetSourceFile, SourceUrl);
  }
}

/**
 * Add a freshly downloaded source file to the list of files to process.
 */
Void Private_LoadSourceFileJson(Text _Url, Text _Body) {
  if (_Url == "" || _Body == "") {
    return;
  }

  declare K_SourceFile SourceFile;
  declare Copied = SourceFile.fromjson(_Body);

  // After all requests are complete, the file is processed in Private_FinalizeSourceFiles().
  G_LibPlayerModels_SourceFilesToProcess[_Url] = SourceFile;
}

/**
 * HTTP requests loading loop.
 */
 Boolean Private_LoadingHttpRequests() {
  while (HttpClient::HasPendingEvents(C_LibPlayerModels_Namespace)) {
    declare Event = HttpClient::GetFirstEvent(C_LibPlayerModels_Namespace);

    if (Event.StatusCode != 200) {
      Private_Log("""Failed to load resource {{{Event.Url}}}""");
    }

    else {
      switch (Event.Id) {
        case C_LibPlayerModels_EventId_GetIndexFile: {
          Private_LoadIndexFileJson(Event.ResponseBody);
        }
        case C_LibPlayerModels_EventId_GetSourceFile: {
          Private_LoadSourceFileJson(Event.Url, Event.ResponseBody);
        }
      }
    }
  }

  return HttpClient::HasPendingRequests(C_LibPlayerModels_Namespace);
}

/**
 * Starts a trak, which fetches user data file names from a given directory.
 */
CTaskResult_FileList Private_CreateUserDataTask(Text _Path) {
  return DataFileMgr.Media_GetFilteredGameList(CDataFileMgr::EMediaType::Skins, 4, _Path, True);
}

/**
 * Awaiting for processed tasks loop.
 */
Boolean Private_LoadingTaskResults() {
  if (G_LibPlayerModels_PendingTasks.count <= 0) return False;

  declare Ident[] TasksToRemove;

  foreach (TaskId => Task in G_LibPlayerModels_PendingTasks) {
    if (Task.IsProcessing) continue;

    foreach (File in Task.Files) {
      G_LibPlayerModels_SkinPathsToProcess.add(File);
    }

    TasksToRemove.add(TaskId);
  }

  while (TasksToRemove.existskey(0)) {
    declare TaskId = TasksToRemove[0];
    declare Removed1 = TasksToRemove.removekey(0);
    declare Removed2 = G_LibPlayerModels_PendingTasks.removekey(TaskId);

    DataFileMgr.TaskResult_Release(TaskId);
  }

  return G_LibPlayerModels_PendingTasks.count > 0;
}

/**
 * Pretty much a spread operator in a `{ ...target, ...source }` fashion.
 */
Text[Text] Private_AppendAssets(Text[Text] _Target, Text[Text] _Source, Text _BaseUrl) {
  declare Result = _Target;

  foreach (Key => Value in _Source) {
    if (Private_IsRelativeUrl(Value)) {
      Result[Key] = Private_FromBaseUrl(_BaseUrl, Value);
    } else {
      Result[Key] = Value;
    }
  }

  return Result;
}

/**
 * Register a new model, or replace existing fields if a value is given.
 */
Void Private_AppendModel(K_Model _Model, Text _BaseUrl) {
  if (!G_LibPlayerModels_ModelById.existskey(_Model.Id)) {
    G_LibPlayerModels_ModelById[_Model.Id] = _Model;
  }

  else {
    if (_Model.Name != "") {
      G_LibPlayerModels_ModelById[_Model.Id].Name = _Model.Name;
    }

    if (_Model.Archetype != "") {
      G_LibPlayerModels_ModelById[_Model.Id].Archetype = _Model.Archetype;
    }

    if (_Model.ItemPath != "") {
      G_LibPlayerModels_ModelById[_Model.Id].ItemPath = _Model.ItemPath;
    }

    if (_Model.LoadAs != "") {
      G_LibPlayerModels_ModelById[_Model.Id].LoadAs = _Model.LoadAs;
    }

    if (_Model.Author != "") {
      G_LibPlayerModels_ModelById[_Model.Id].Author = _Model.Author;
    }
  }

  if (_Model.Assets.count > 0) {
    G_LibPlayerModels_ModelById[_Model.Id].Assets = Private_AppendAssets(G_LibPlayerModels_ModelById[_Model.Id].Assets, _Model.Assets, _BaseUrl);
  }
}

/**
 * Register a new skin, or replace existing fields if a value is given.
 */
Void Private_AppendSkin(K_Skin _Skin, Text _BaseUrl) {
  if (!G_LibPlayerModels_SkinById.existskey(_Skin.Id)) {
    G_LibPlayerModels_SkinById[_Skin.Id] = _Skin;
  }

  else {
    if (_Skin.Name != "") {
      G_LibPlayerModels_SkinById[_Skin.Id].Name = _Skin.Name;
    }

    if (_Skin.AppliesTo != "") {
      G_LibPlayerModels_SkinById[_Skin.Id].AppliesTo = _Skin.AppliesTo;
    }

    if (_Skin.SkinPath != "") {
      G_LibPlayerModels_SkinById[_Skin.Id].SkinPath = _Skin.SkinPath;
    }

    if (_Skin.Author != "") {
      G_LibPlayerModels_SkinById[_Skin.Id].Author = _Skin.Author;
    }

    if (_Skin.Rarity > 0) {
      G_LibPlayerModels_SkinById[_Skin.Id].Rarity = _Skin.Rarity;
    }

    if (_Skin.SortIndex != 0) {
      G_LibPlayerModels_SkinById[_Skin.Id].Rarity = _Skin.SortIndex;
    }
  }

  if (_Skin.Assets.count > 0) {
    G_LibPlayerModels_SkinById[_Skin.Id].Assets = Private_AppendAssets(G_LibPlayerModels_SkinById[_Skin.Id].Assets, _Skin.Assets, _BaseUrl);
  }
}

/**
 * Register a new gameplay overlay or replace existing fields if a value is given.
 */
Void Private_AppendOverlay(K_Overlay _Overlay, Text _BaseUrl) {
  if (!G_LibPlayerModels_OverlayById.existskey(_Overlay.Id)) {
    G_LibPlayerModels_OverlayById[_Overlay.Id] = _Overlay;
  }

  else {
    if (_Overlay.Name != "") {
      G_LibPlayerModels_OverlayById[_Overlay.Id].Name = _Overlay.Name;
    }

    if (_Overlay.Extends != "") {
      G_LibPlayerModels_OverlayById[_Overlay.Id].Extends = _Overlay.Extends;
    }

    if (_Overlay.ItemPath != "") {
      G_LibPlayerModels_OverlayById[_Overlay.Id].ItemPath = _Overlay.ItemPath;
    }
  }

  if (_Overlay.Assets.count > 0) {
    G_LibPlayerModels_OverlayById[_Overlay.Id].Assets = Private_AppendAssets(G_LibPlayerModels_OverlayById[_Overlay.Id].Assets, _Overlay.Assets, _BaseUrl);
  }
}

/**
 * Get the model from a skin directory.
 */
Text Private_ResolvePlayerModelIdFromSkinDirectory(Text _SkinDirectory) {
  // CarCommon quick check (direct).
  if (_SkinDirectory == C_LibPlayerModels_CarCommonDirectory) {
    return C_LibPlayerModels_CarCommonWildcard;
  }

  // The skin file sits directly in a defined folder.
  if (G_LibPlayerModels_ModelIdBySkinDirectory.existskey(_SkinDirectory)) {
    return G_LibPlayerModels_ModelIdBySkinDirectory[_SkinDirectory];
  }

  // For subfolders, match the most specific path.
  foreach (SkinDirectory => ModelId in G_LibPlayerModels_ModelIdBySkinDirectory) {
    if (TL::StartsWith(_SkinDirectory, SkinDirectory, True, False)) {
      return ModelId;
    }
  }

  // CarCommon slow check (subfolder).
  if (TL::StartsWith(_SkinDirectory, C_LibPlayerModels_CarCommonDirectory, True, False)) {
    return C_LibPlayerModels_CarCommonWildcard;
  }

  return "";
}

/**
 * Parse user directory skin path and append a skin if a matching model is found.
 */
K_Skin Private_CreateSkinFromPath(Text _SkinPath) {
  declare Match = TL::RegexMatch(C_LibPlayerModels_RegexMatchUserSkinPath, _SkinPath, "i");

  if (Match.count != 3) {
    return K_Skin {};
  }

  declare ModelId = Private_ResolvePlayerModelIdFromSkinDirectory(Match[1]^"\\");

  if (ModelId == "") {
    return K_Skin {};
  }

  return K_Skin {
    Id = """{{{C_LibPlayerModels_UserSkinsNamespace}}}:{{{_SkinPath}}}""",
    AppliesTo = ModelId,
    Name = Match[2],
    SkinPath = """file://Skins/{{{TL::Replace(_SkinPath, "\\", "/")}}}"""
  };
}

/**
 * Once every source file has been loaded, load the data from all of them at once.
 */
Void Private_FinalizeSourceFiles() {
  if (G_LibPlayerModels_SourceFilesToProcess.count <= 0) {
    return;
  }

  // Wipe existing data.
  G_LibPlayerModels_OverlayById.clear();
  G_LibPlayerModels_ModelById.clear();
  G_LibPlayerModels_SkinById.clear();
  G_LibPlayerModels_ModelIdByItemPath.clear();
  G_LibPlayerModels_ModelIdBySkinDirectory.clear();

  // Source files could have been loaded in a different order than in the index file.
  // Here we are ensuring that the original file order is restored and models are loaded with correct priority.
  declare Text[Integer] SortedSourceFiles = [];

  foreach (Url => SourceFile in G_LibPlayerModels_SourceFilesToProcess) {
    declare Index = G_LibPlayerModels_SourceFilesOrder.keyof(Url);

    SortedSourceFiles[Index] = Url;
  }

  SortedSourceFiles = SortedSourceFiles.sortkey();

  // Used exclusively for the display naming convention.
  declare NbCharacters = 0;
  declare NbVehicles = 0;

  // Source files are iterated two separate times, and that is intended.
  // We want to be absolutely sure that all base models are loaded before everything else.
  foreach (Url in SortedSourceFiles) {
    declare SourceFile = G_LibPlayerModels_SourceFilesToProcess[Url];
    declare BaseUrl = Private_GetBaseUrl(Url);

    foreach (Model in SourceFile.Models) {
      if (Model.Id == "") {
        continue;
      }

      foreach (SkinDirectory in Model.SkinDirectories) {
        G_LibPlayerModels_ModelIdBySkinDirectory[SkinDirectory^"\\"] = Model.Id;
      }

      Private_AppendModel(Model, BaseUrl);

      if (Private_IsCharacter(Model.Archetype)) {
        NbCharacters += 1;
      } else {
        NbVehicles += 1;
      }
    }
  }

  // Reverse sorting allows the deepest subfolders to be checked first.
  G_LibPlayerModels_ModelIdBySkinDirectory = G_LibPlayerModels_ModelIdBySkinDirectory.sortkeyreverse();

  // Append skins and overlays.
  foreach (Url in SortedSourceFiles) {
    declare SourceFile = G_LibPlayerModels_SourceFilesToProcess[Url];
    declare BaseUrl = Private_GetBaseUrl(Url);

    foreach (Skin in SourceFile.Skins) {
      if (Skin.Id == "" || (!G_LibPlayerModels_ModelById.existskey(Skin.AppliesTo) && Skin.Id != C_LibPlayerModels_CarCommonWildcard)) {
        continue;
      }

      Private_AppendSkin(Skin, BaseUrl);
    }

    foreach (Overlay in SourceFile.Overlays) {
      if (Overlay.Id == "" || !G_LibPlayerModels_ModelById.existskey(Overlay.Extends)) {
        continue;
      }

      Private_AppendOverlay(Overlay, BaseUrl);
    }
  }

  // Creates dummy skin entries from the user Skins directory files.
  foreach (File in G_LibPlayerModels_SkinPathsToProcess) {
    declare Skin = Private_CreateSkinFromPath(File);

    if (Skin.Id == "") {
      continue;
    }

    Private_AppendSkin(Skin, "");
  }

  // Create model aliases.
  foreach (ModelId => Model in G_LibPlayerModels_ModelById) {
    declare Archetype = Private_NormalizeItemName(Model.Archetype);
    declare ItemPath = Private_NormalizeItemPath(Model.ItemPath);
    declare ItemName = Private_NormalizeItemName(Model.ItemPath);

    if (Archetype != "" && !G_LibPlayerModels_ModelIdByItemPath.existskey(Archetype)) {
      G_LibPlayerModels_ModelIdByItemPath[Archetype] = ModelId;
    }

    if (ItemPath != "" && !G_LibPlayerModels_ModelIdByItemPath.existskey(ItemPath)) {
      G_LibPlayerModels_ModelIdByItemPath[ItemPath] = ModelId;
    }

    if (ItemName != "" && !G_LibPlayerModels_ModelIdByItemPath.existskey(ItemName)) {
      G_LibPlayerModels_ModelIdByItemPath[ItemName] = ModelId;
    }
  }

  // Create model overlay aliases.
  foreach (OverlayId => Overlay in G_LibPlayerModels_OverlayById) {
    declare ItemPath = Private_NormalizeItemPath(Overlay.ItemPath);
    declare ItemName = Private_NormalizeItemName(Overlay.ItemPath);

    if (ItemPath != "" && !G_LibPlayerModels_ModelIdByItemPath.existskey(ItemPath)) {
      G_LibPlayerModels_ModelIdByItemPath[ItemPath] = OverlayId;
    }

    if (ItemName != "" && !G_LibPlayerModels_ModelIdByItemPath.existskey(ItemName)) {
      G_LibPlayerModels_ModelIdByItemPath[ItemName] = OverlayId;
    }
  }

  declare NbModels = G_LibPlayerModels_ModelById.count;
  declare NbSkins = G_LibPlayerModels_SkinById.count;
  declare NbOverlays = G_LibPlayerModels_OverlayById.count;
  declare LoadTime = Now - G_LibPlayerModels_LoadingStartTime;

  // Apply the correct naming convention, depending on the loaded model types.
  if (NbModels == NbCharacters) {
    G_LibPlayerModels_ModelTypeCategory = C_LibPlayerModels_ModelType_Character;
  }

  if (NbModels == NbVehicles) {
    G_LibPlayerModels_ModelTypeCategory = C_LibPlayerModels_ModelType_Vehicle;
  }

  Private_Log("""Loaded data of {{{NbModels}}} models, {{{NbSkins}}} skins, {{{NbOverlays}}} overlays in {{{LoadTime}}} ms""");
}

// ---------------------------------- //
// Public functions
// ---------------------------------- //

Void Unload() {
  foreach (TaskId => __ in G_LibPlayerModels_PendingTasks) {
    DataFileMgr.TaskResult_Release(TaskId);
  }

  G_LibPlayerModels_Options = K_Options {};
  G_LibPlayerModels_LoadingStartTime = -1;
  G_LibPlayerModels_SourceFilesOrder.clear();
  G_LibPlayerModels_SourceFilesToProcess.clear();
  G_LibPlayerModels_PendingTasks.clear();
  G_LibPlayerModels_SkinPathsToProcess.clear();
  G_LibPlayerModels_ModelTypeCategory = "";
  G_LibPlayerModels_SortingOverrides.clear();
  G_LibPlayerModels_ModelById.clear();
  G_LibPlayerModels_SkinById.clear();
  G_LibPlayerModels_OverlayById.clear();
  G_LibPlayerModels_ModelIdByItemPath.clear();
  G_LibPlayerModels_ModelIdBySkinDirectory.clear();
}

/**
 * Starts loading the data from the index file.
 *
 * You should do a `while (Loading()) MB_Yield();` loop right after calling Load().
 */
Void Load(K_Options _Options) {
  Unload();

  G_LibPlayerModels_Options = _Options;
  G_LibPlayerModels_LoadingStartTime = Now;

  if (G_LibPlayerModels_Options.IndexFileUrl == "") {
    G_LibPlayerModels_Options.IndexFileUrl = C_LibPlayerModels_DefaultIndexFileUrl;
  }

  if (!HttpClient::IsValidUrl(G_LibPlayerModels_Options.IndexFileUrl)) {
    return;
  }

  HttpClient::Get(C_LibPlayerModels_EventId_GetIndexFile, G_LibPlayerModels_Options.IndexFileUrl);

  if (!G_LibPlayerModels_Options.LoadUserSkinsDirectory || DataFileMgr == Null) {
    return;
  }

  foreach (Directory in C_LibPlayerModels_UserSkinsDirectories) {
    declare Task <=> Private_CreateUserDataTask(Directory);

    G_LibPlayerModels_PendingTasks[Task.Id] = Task;
  }
}

Void Load() {
  Load(K_Options {});
}

/**
 * @returns True while data is being loaded.
 */
Boolean Loading() {
  // Must call outside of the OR operator for all the loops to execute concurrently.
  declare IsLoadingHttp = Private_LoadingHttpRequests();
  declare IsLoadingTasks = Private_LoadingTaskResults();

  declare IsLoading = IsLoadingHttp || IsLoadingTasks;

  if (!IsLoading) {
    Private_FinalizeSourceFiles();
  }

  return IsLoading;
}

/**
 * @returns "Characters", "Vehicles" or "" for empty or mixed model types.
 */
Text ModelTypeCategory() {
  return G_LibPlayerModels_ModelTypeCategory;
}

/**
 * @returns Custom model id resolved from the item path.
 * @example `Vehicles/IslandCar.Item.Gbx` -> `trackmania:islandcar`
 */
Text ResolveModelId(Text _ItemPath) {
  if (G_LibPlayerModels_ModelIdByItemPath.exists(_ItemPath)) {
    return _ItemPath;
  }

  declare ItemPath = Private_NormalizeItemPath(_ItemPath);

  if (G_LibPlayerModels_ModelIdByItemPath.existskey(ItemPath)) {
    return G_LibPlayerModels_ModelIdByItemPath[ItemPath];
  }

  return "";
}

/**
 * @returns Base custom model id of the gameplay extension, or the custom model id itself.
 */
Text GetBaseModelId(Text _ModelId) {
  if (G_LibPlayerModels_OverlayById.existskey(_ModelId)) {
    return G_LibPlayerModels_OverlayById[_ModelId].Extends;
  }

  if (G_LibPlayerModels_ModelById.existskey(_ModelId)) {
    return _ModelId;
  }

  return "";
}

K_Model[Text] GetAllModels() {
  return G_LibPlayerModels_ModelById;
}

K_Skin[Text] GetAllSkins() {
  return G_LibPlayerModels_SkinById;
}

K_Overlay[Text] GetAllOverlays() {
  return G_LibPlayerModels_OverlayById;
}

K_Model[] GetModelsList(Boolean _IncludeHidden) {
  declare SortedModelIds = G_LibPlayerModels_SortingOverrides;

  foreach (ModelId => __ in G_LibPlayerModels_ModelById) {
    if (!SortedModelIds.exists(ModelId)) {
      SortedModelIds.add(ModelId);
    }
  }

  declare K_Model[] Result;

  foreach (ModelId in SortedModelIds) {
    if (!G_LibPlayerModels_ModelById.existskey(ModelId)) {
      continue;
    }

    declare Model = G_LibPlayerModels_ModelById[ModelId];

    if (!_IncludeHidden && Model.IsHidden) {
      continue;
    }

    Result.add(Model);
  }

  return Result;
}

K_Model[] GetModelsList() {
  return GetModelsList(False);
}

K_Skin[] GetSkinsListByModelId(Text _ModelId, Boolean _IncludeHidden) {
  declare BaseModelId = GetBaseModelId(_ModelId);
  declare K_Skin[] Result;

  foreach (Skin in G_LibPlayerModels_SkinById) {
    if (Skin.AppliesTo != BaseModelId && Skin.AppliesTo != C_LibPlayerModels_CarCommonWildcard) {
      continue;
    }

    if (!_IncludeHidden && Skin.IsHidden) {
      continue;
    }

    Result.add(Skin);
  }

  return Result;
}

K_Skin[] GetSkinsListByModelId(Text _ModelId) {
  return GetSkinsListByModelId(_ModelId, False);
}

Text GetRandomSkinIdByModelId(Text _ModelId, Boolean _IncludeHidden) {
  declare Skins = GetSkinsListByModelId(_ModelId, _IncludeHidden);

  if (Skins.count <= 0) {
    return "";
  }

  if (Skins.count == 1) {
    return Skins[0].Id;
  }

  declare Index = ML::Rand(0, Skins.count - 1);

  return Skins[Index].Id;
}

Text GetRandomSkinIdByModelId(Text _ModelId) {
  return GetRandomSkinIdByModelId(_ModelId, False);
}

Text GetModelArchetype(Text _ModelId) {
  declare BaseModelId = GetBaseModelId(_ModelId);

  if (G_LibPlayerModels_ModelById.existskey(_ModelId)) {
    return G_LibPlayerModels_ModelById[_ModelId].Archetype;
  }

  return "";
}

Boolean GetArchetypeIsUnitedVehicle(Text _Archetype) {
  return C_LibPlayerModels_TMUnitedArchetypes.exists(_Archetype);
}

Boolean GetPlayerModelIsUnitedVehicle(Text _ModelId) {
  return GetArchetypeIsUnitedVehicle(GetModelArchetype(_ModelId));
}

K_GameplayInfo GetPlayerModelGameplayInfo(Text _ModelId) {
  declare DefaultResult = K_GameplayInfo {
    AccelCoef = 1.0,
    ControlCoef = 1.0,
    GravityCoef = 1.0
  };

  if (!G_LibPlayerModels_OverlayById.existskey(_ModelId)) {
    return DefaultResult;
  }

  declare GameplayInfo = G_LibPlayerModels_OverlayById[_ModelId].Gameplay;

  if (GameplayInfo.AccelCoef != 0.0 || GameplayInfo.ControlCoef != 0.0 || GameplayInfo.GravityCoef != 0.0) {
    return GameplayInfo;
  }

  return DefaultResult;
}

Text GetOverlayAsset(Text _OverlayId, Text _AssetId, Text _Fallback) {
  if (!G_LibPlayerModels_OverlayById.existskey(_OverlayId)) return _Fallback;
  if (!G_LibPlayerModels_OverlayById[_OverlayId].Assets.existskey(_AssetId)) return _Fallback;

  return G_LibPlayerModels_OverlayById[_OverlayId].Assets[_AssetId];
}

Text GetPlayerModelAsset(Text _ModelId, Text _AssetId, Text _Fallback) {
  if (G_LibPlayerModels_ModelById.existskey(_ModelId)) {
    if (!G_LibPlayerModels_ModelById[_ModelId].Assets.existskey(_AssetId)) return _Fallback;
    return G_LibPlayerModels_ModelById[_ModelId].Assets[_AssetId];
  }

  // Fallback to overlay.
  return GetOverlayAsset(_ModelId, _AssetId, _Fallback);
}

Text GetSkinAsset(Text _SkinId, Text _AssetId, Text _Fallback) {
  if (!G_LibPlayerModels_SkinById.existskey(_SkinId)) return _Fallback;

  if (G_LibPlayerModels_SkinById[_SkinId].Assets.existskey(_AssetId)) {
    return G_LibPlayerModels_SkinById[_SkinId].Assets[_AssetId];
  }

  // Fallback to model.
  return GetPlayerModelAsset(G_LibPlayerModels_SkinById[_SkinId].AppliesTo, _AssetId, _Fallback);
}
