/**
 * @name PlayerModels_Data.Script.txt
 * @author domino54
 * @version 2024-10-15
 */

#Const Version      "2024-10-15"
#Const ScriptName   "Libs/domino54/PlayerModels_Data.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/Log.Script.txt" as Log
#Include "Libs/domino54/HttpClient.Script.txt" as HttpClient
#Include "Libs/domino54/PlayerModels_Structs.Script.txt" as Structs

// ---------------------------------- //
// Constants
// ---------------------------------- //

#Const C_LibPlayerModels_Namespace                "player_models"
#Const C_LibPlayerModels_EventId_GetIndexFile     "player_models:index"
#Const C_LibPlayerModels_EventId_GetSourceFile    "player_models:source"
#Const C_LibPlayerModels_DefaultIndexFileUrl      "file://Media/Data/PlayerModels/index.json"
#Const C_LibPlayerModels_DataLoadingTimeout       10000
#Const C_LibPlayerModels_ModelType_Character      "Character"
#Const C_LibPlayerModels_ModelType_Vehicle        "Vehicle"
#Const C_LibPlayerModels_LoadAs_Archetype         "Archetype"
#Const C_LibPlayerModels_LoadAs_Item              "Item"
#Const C_LibPlayerModels_LoadAs_ItemAndArchetype  "ItemAndArchetype"
#Const C_LibPlayerModels_CarCommonWildcard        "*"
#Const C_LibPlayerModels_CarCommonDirectory       "CarCommon\\"
#Const C_LibPlayerModels_UserSkinsDirectories     ["Models", "Vehicles"]
#Const C_LibPlayerModels_UserSkinsNamespace       "userdata"
#Const C_LibPlayerModels_RegexFileNameFull        "[^\\/\\\\]+$"
#Const C_LibPlayerModels_RegexItemName            "([^\\/\\\\]+)\\.Item\\.Gbx$"
#Const C_LibPlayerModels_RegexReplacedSlashes     "[\\/\\\\]"
#Const C_LibPlayerModels_RegexMatchUserSkinPath   "^[^\\\\]+\\\\(.+)\\\\([^\\\\]+)\\.zip$"
#Const C_LibPlayerModels_CharacterArchetypes      ["ArenaPlayer", "Minion"]
#Const C_LibPlayerModels_TMUnitedArchetypes       ["DesertCar", "SnowCar", "RallyCar", "IslandCar", "BayCar", "CoastCar", "StadiumCar"]

// ---------------------------------- //
// Structs
// ---------------------------------- //

#Struct Structs::K_Model as K_Model
#Struct Structs::K_Skin as K_Skin
#Struct Structs::K_Overlay as K_Overlay
#Struct Structs::K_GameplayInfo as K_GameplayInfo

#Struct K_Options {
  /** Override the default index file URL. */
  Text IndexFileUrl;

  /** URLs of additional source files to load. */
  Text[] ExtraSourceFilesUrls;

  /** Interpret the user's skin directory for custom skin selection purposes. */
  Boolean LoadUserSkinsDirectory;
}

/// An index file references paths to all data source files to load.
/// Ideally load them from subdirectories of file://Media/Data/PlayerModels/
#Struct K_IndexFile {
  Text[] SourceUrls;
  Text[] SortOverrides;
}

/// A source file describes gameplay models and skins applicable to them.
#Struct K_SourceFile {
  Text Id;
  K_Model[] Models;
  K_Skin[] Skins;
  K_Overlay[] Overlays;
}

// ---------------------------------- //
// Global variables
// ---------------------------------- //

declare CTaskResult_FileList[Ident] G_LibPlayerModels_PendingTasks;

// ---------------------------------- //
// Private functions
// ---------------------------------- //

Void Private_Log(Text _Message) {
  Log::Log("""[PlayerModels_Data] {{{_Message}}}""");
}

Text Private_GetBaseUrl(Text _Url) {
  return TL::RegexReplace(C_LibPlayerModels_RegexFileNameFull, _Url, "i", "");
}

Boolean Private_IsRelativeUrl(Text _Value) {
  return TL::StartsWith("./", _Value) || TL::StartsWith(".\\", _Value);
}

/**
 * Glue a relative path to the base url.
 * Assumes that `_RelativePath` starts with "./" as the first 2 characters are skipped.
 */
Text Private_FromBaseUrl(Text _BaseUrl, Text _RelativePath) {
  return _BaseUrl ^ TL::SubString(_RelativePath, 2, TL::Length(_RelativePath) - 2);
}

/**
 * Removes the namespace from an id.
 *
 * `trackmania:canyoncar` -> `canyoncar`
 * `stadiumcar` -> `stadiumcar`
 * `malformed:name:text` -> `name`
 */
Text Private_TrimNamespace(Text _Id) {
  declare Split = TL::Split(":", _Id);

  if (Split.existskey(1)) {
    return Split[1];
  }

  return _Id;
}

/**
 * Normalizes the item path to a simplified string.
 * This name is used later to look up the custom model id.
 *
 * `StadiumCar` -> `StadiumCar`
 * `CanyonCar.Item.Gbx` -> `CanyonCar`
 * `Vehicles/IslandCar.Item.Gbx` -> `IslandCar`
 */
Text Private_NormalizeItemName(Text _ItemPath) {
  declare Match = TL::RegexMatch(C_LibPlayerModels_RegexItemName, _ItemPath, "i");

  if (Match.count < 2 || Match[1] == "") {
    return _ItemPath;
  }

  return Match[1];
}

/**
 * Normalizes the item path to a simplified path.
 * @example `Vehicles\\CanyonCar.Item.Gbx` -> `Vehicles/CanyonCar.Item.Gbx`
 */
Text Private_NormalizeItemPath(Text _ItemPath) {
  return TL::ToLowerCase(TL::RegexReplace(C_LibPlayerModels_RegexReplacedSlashes, _ItemPath, "i", "/"));
}

/**
 * Check if an archetype is a character.
 */
Boolean Private_IsCharacter(Text _Archetype) {
  return C_LibPlayerModels_CharacterArchetypes.exists(_Archetype);
}

/**
 * Load the metadata from the previously downloaded index file.
 */
Void Private_LoadIndexFileJson(Text _Body) {
  if (_Body == "") {
    return;
  }

  declare K_IndexFile IndexFile;
  declare Copied = IndexFile.fromjson(_Body);

  declare Integer LibPlayerModels_LoadingStartTime for LoadedTitle;
  declare K_Options LibPlayerModels_Options for LoadedTitle;
  declare Text[] LibPlayerModels_SortingOverrides for LoadedTitle;
  declare Text[] LibPlayerModels_SourceFilesOrder for LoadedTitle;

  LibPlayerModels_SortingOverrides = IndexFile.SortOverrides;
  LibPlayerModels_SourceFilesOrder.clear();

  // These are added on top of everything, if the game mode wants to load extra models.
  foreach (ExtraSourceUrl in LibPlayerModels_Options.ExtraSourceFilesUrls) {
    IndexFile.SourceUrls.add(ExtraSourceUrl);
  }

  if (IndexFile.SourceUrls.count <= 0) {
    LibPlayerModels_LoadingStartTime = -1;
    return;
  }

  declare BaseUrl = Private_GetBaseUrl(LibPlayerModels_Options.IndexFileUrl);

  foreach (RawSourceUrl in IndexFile.SourceUrls) {
    declare SourceUrl = RawSourceUrl;

    if (Private_IsRelativeUrl(SourceUrl)) {
      SourceUrl = Private_FromBaseUrl(BaseUrl, SourceUrl);
    }

    if (!HttpClient::IsValidUrl(SourceUrl)) {
      continue;
    }

    // Is later used to apply models in the correct order from the index file.
    LibPlayerModels_SourceFilesOrder.add(SourceUrl);

    HttpClient::Get(C_LibPlayerModels_EventId_GetSourceFile, SourceUrl);
  }
}

/**
 * Add a freshly downloaded source file to the list of files to process.
 */
Void Private_LoadSourceFileJson(Text _Url, Text _Body) {
  if (_Url == "" || _Body == "") {
    return;
  }

  declare K_SourceFile SourceFile;
  declare Copied = SourceFile.fromjson(_Body);

  declare K_SourceFile[Text] LibPlayerModels_SourceFilesToProcess for LoadedTitle;

  // After all requests are complete, the file is processed in Private_FinalizeSourceFiles().
  LibPlayerModels_SourceFilesToProcess[_Url] = SourceFile;
}

/**
 * HTTP requests loading loop.
 */
 Boolean Private_LoadingHttpRequests() {
  while (HttpClient::HasPendingEvents(C_LibPlayerModels_Namespace)) {
    declare Event = HttpClient::GetFirstEvent(C_LibPlayerModels_Namespace);

    if (Event.StatusCode != 200) {
      Private_Log("""Failed to load resource {{{Event.Url}}}""");
    }

    else {
      switch (Event.Id) {
        case C_LibPlayerModels_EventId_GetIndexFile: {
          Private_LoadIndexFileJson(Event.ResponseBody);
        }
        case C_LibPlayerModels_EventId_GetSourceFile: {
          Private_LoadSourceFileJson(Event.Url, Event.ResponseBody);
        }
      }
    }
  }

  return HttpClient::HasPendingRequests(C_LibPlayerModels_Namespace);
}

/**
 * Starts a trak, which fetches user data file names from a given directory.
 */
CTaskResult_FileList Private_CreateUserDataTask(Text _Path) {
  return DataFileMgr.Media_GetFilteredGameList(CDataFileMgr::EMediaType::Skins, 4, _Path, True);
}

/**
 * Awaiting for processed tasks loop.
 */
Boolean Private_LoadingTaskResults() {
  if (G_LibPlayerModels_PendingTasks.count <= 0) return False;

  declare Ident[] TasksToRemove;

  foreach (TaskId => Task in G_LibPlayerModels_PendingTasks) {
    if (Task.IsProcessing) continue;

    foreach (File in Task.Files) {
      declare Text[] LibPlayerModels_SkinPathsToProcess for LoadedTitle;

      LibPlayerModels_SkinPathsToProcess.add(File);
    }

    TasksToRemove.add(TaskId);
  }

  while (TasksToRemove.existskey(0)) {
    declare TaskId = TasksToRemove[0];
    declare Removed1 = TasksToRemove.removekey(0);
    declare Removed2 = G_LibPlayerModels_PendingTasks.removekey(TaskId);

    DataFileMgr.TaskResult_Release(TaskId);
  }

  return G_LibPlayerModels_PendingTasks.count > 0;
}

/**
 * Pretty much a spread operator in a `{ ...target, ...source }` fashion.
 */
Text[Text] Private_AppendAssets(Text[Text] _Target, Text[Text] _Source, Text _BaseUrl) {
  declare Result = _Target;

  foreach (Key => Value in _Source) {
    if (Private_IsRelativeUrl(Value)) {
      Result[Key] = Private_FromBaseUrl(_BaseUrl, Value);
    } else {
      Result[Key] = Value;
    }
  }

  return Result;
}

/**
 * Register a new model, or replace existing fields if a value is given.
 */
Void Private_AppendModel(K_Model _Model, Text _BaseUrl) {
  declare K_Model[Text] LibPlayerModels_ModelById for LoadedTitle;

  if (!LibPlayerModels_ModelById.existskey(_Model.Id)) {
    LibPlayerModels_ModelById[_Model.Id] = _Model;
  }

  else {
    if (_Model.Name != "") {
      LibPlayerModels_ModelById[_Model.Id].Name = _Model.Name;
    }

    if (_Model.Archetype != "") {
      LibPlayerModels_ModelById[_Model.Id].Archetype = _Model.Archetype;
    }

    if (_Model.ItemPath != "") {
      LibPlayerModels_ModelById[_Model.Id].ItemPath = _Model.ItemPath;
    }

    if (_Model.LoadAs != "") {
      LibPlayerModels_ModelById[_Model.Id].LoadAs = _Model.LoadAs;
    }

    if (_Model.Author != "") {
      LibPlayerModels_ModelById[_Model.Id].Author = _Model.Author;
    }
  }

  if (_Model.Assets.count > 0) {
    LibPlayerModels_ModelById[_Model.Id].Assets = Private_AppendAssets(LibPlayerModels_ModelById[_Model.Id].Assets, _Model.Assets, _BaseUrl);
  }
}

/**
 * Register a new skin, or replace existing fields if a value is given.
 */
Void Private_AppendSkin(K_Skin _Skin, Text _BaseUrl) {
  declare K_Skin[Text] LibPlayerModels_SkinById for LoadedTitle;

  if (!LibPlayerModels_SkinById.existskey(_Skin.Id)) {
    LibPlayerModels_SkinById[_Skin.Id] = _Skin;
  }

  else {
    if (_Skin.Name != "") {
      LibPlayerModels_SkinById[_Skin.Id].Name = _Skin.Name;
    }

    if (_Skin.AppliesTo != "") {
      LibPlayerModels_SkinById[_Skin.Id].AppliesTo = _Skin.AppliesTo;
    }

    if (_Skin.SkinPath != "") {
      LibPlayerModels_SkinById[_Skin.Id].SkinPath = _Skin.SkinPath;
    }

    if (_Skin.Author != "") {
      LibPlayerModels_SkinById[_Skin.Id].Author = _Skin.Author;
    }

    if (_Skin.Rarity > 0) {
      LibPlayerModels_SkinById[_Skin.Id].Rarity = _Skin.Rarity;
    }

    if (_Skin.SortIndex != 0) {
      LibPlayerModels_SkinById[_Skin.Id].Rarity = _Skin.SortIndex;
    }
  }

  if (_Skin.Assets.count > 0) {
    LibPlayerModels_SkinById[_Skin.Id].Assets = Private_AppendAssets(LibPlayerModels_SkinById[_Skin.Id].Assets, _Skin.Assets, _BaseUrl);
  }
}

/**
 * Register a new gameplay overlay or replace existing fields if a value is given.
 */
Void Private_AppendOverlay(K_Overlay _Overlay, Text _BaseUrl) {
  declare K_Overlay[Text] LibPlayerModels_OverlayById for LoadedTitle;

  if (!LibPlayerModels_OverlayById.existskey(_Overlay.Id)) {
    LibPlayerModels_OverlayById[_Overlay.Id] = _Overlay;
  }

  else {
    if (_Overlay.Name != "") {
      LibPlayerModels_OverlayById[_Overlay.Id].Name = _Overlay.Name;
    }

    if (_Overlay.Extends != "") {
      LibPlayerModels_OverlayById[_Overlay.Id].Extends = _Overlay.Extends;
    }

    if (_Overlay.ItemPath != "") {
      LibPlayerModels_OverlayById[_Overlay.Id].ItemPath = _Overlay.ItemPath;
    }
  }

  if (_Overlay.Assets.count > 0) {
    LibPlayerModels_OverlayById[_Overlay.Id].Assets = Private_AppendAssets(LibPlayerModels_OverlayById[_Overlay.Id].Assets, _Overlay.Assets, _BaseUrl);
  }
}

/**
 * Get the model from a skin directory.
 */
Text Private_ResolvePlayerModelIdFromSkinDirectory(Text _SkinDirectory) {
  // CarCommon quick check (direct).
  if (_SkinDirectory == C_LibPlayerModels_CarCommonDirectory) {
    return C_LibPlayerModels_CarCommonWildcard;
  }

  declare Text[Text] LibPlayerModels_ModelIdBySkinDirectory for LoadedTitle;

  // The skin file sits directly in a defined folder.
  if (LibPlayerModels_ModelIdBySkinDirectory.existskey(_SkinDirectory)) {
    return LibPlayerModels_ModelIdBySkinDirectory[_SkinDirectory];
  }

  // For subfolders, match the most specific path.
  foreach (SkinDirectory => ModelId in LibPlayerModels_ModelIdBySkinDirectory) {
    if (TL::StartsWith(_SkinDirectory, SkinDirectory, True, False)) {
      return ModelId;
    }
  }

  // CarCommon slow check (subfolder).
  if (TL::StartsWith(_SkinDirectory, C_LibPlayerModels_CarCommonDirectory, True, False)) {
    return C_LibPlayerModels_CarCommonWildcard;
  }

  return "";
}

/**
 * Parse user directory skin path and append a skin if a matching model is found.
 */
K_Skin Private_CreateSkinFromPath(Text _SkinPath) {
  declare Match = TL::RegexMatch(C_LibPlayerModels_RegexMatchUserSkinPath, _SkinPath, "i");

  if (Match.count != 3) {
    return K_Skin {};
  }

  declare ModelId = Private_ResolvePlayerModelIdFromSkinDirectory(Match[1]^"\\");

  if (ModelId == "") {
    return K_Skin {};
  }

  return K_Skin {
    Id = """{{{C_LibPlayerModels_UserSkinsNamespace}}}:{{{_SkinPath}}}""",
    AppliesTo = ModelId,
    Name = Match[2],
    SkinPath = """file://Skins/{{{TL::Replace(_SkinPath, "\\", "/")}}}"""
  };
}

/**
 * Add a lowercase alias to a model id.
 */
Void Private_AppendModelIdAlias(Text _ModelId, Text _Alias) {
  if (_ModelId == "" || _Alias == "") {
    return;
  }

  declare Alias = TL::ToLowerCase(_Alias);

  /**
   * Stores the custom model id by the respective item path.
   * ["canyoncar" => "trackmania:canyoncar"]
   * ["vehicles/trafficcar.item.gbx" => "trackmania:trafficcar"]
   * ["valleycar4x" => "tmall:valleycar4x"]
   */
  declare Text[Text] LibPlayerModels_ModelIdByAlias for LoadedTitle;

  if (LibPlayerModels_ModelIdByAlias.existskey(Alias)) {
    return;
  }

  LibPlayerModels_ModelIdByAlias[Alias] = _ModelId;
}

/**
 * Bulk create aliases for a model.
 */
Void Private_CreateModelAliases(K_Model[Text] _ModelById) {
  foreach (ModelId => Model in _ModelById) {
    Private_AppendModelIdAlias(ModelId, ModelId); // Case-insensitive alias.
    Private_AppendModelIdAlias(ModelId, Private_TrimNamespace(ModelId));
    Private_AppendModelIdAlias(ModelId, Private_NormalizeItemName(Model.Archetype));
    Private_AppendModelIdAlias(ModelId, Private_NormalizeItemPath(Model.ItemPath));
    Private_AppendModelIdAlias(ModelId, Private_NormalizeItemName(Model.ItemPath));
  }
}

/**
 * Bulk create aliases for an overlay.
 */
Void Private_CreateOverlayAliases(K_Overlay[Text] _OverlayById) {
  foreach (OverlayId => Overlay in _OverlayById) {
    Private_AppendModelIdAlias(OverlayId, OverlayId); // Case-insensitive alias.
    Private_AppendModelIdAlias(OverlayId, Private_TrimNamespace(OverlayId));
    Private_AppendModelIdAlias(OverlayId, Private_NormalizeItemPath(Overlay.ItemPath));
    Private_AppendModelIdAlias(OverlayId, Private_NormalizeItemName(Overlay.ItemPath));
  }
}

/**
 * Once every source file has been loaded, load the data from all of them at once.
 */
Void Private_FinalizeSourceFiles() {
  declare K_SourceFile[Text] LibPlayerModels_SourceFilesToProcess for LoadedTitle;
  declare Integer LibPlayerModels_LoadingStartTime for LoadedTitle;

  if (LibPlayerModels_SourceFilesToProcess.count <= 0) {
    LibPlayerModels_LoadingStartTime = -1;
    return;
  }

  // Source files could have been loaded in a different order than in the index file.
  // Here we are ensuring that the original file order is restored and models are loaded with correct priority.
  declare Text[] LibPlayerModels_SourceFilesOrder for LoadedTitle;
  declare Text[Integer] SortedSourceFiles = [];

  foreach (Url => SourceFile in LibPlayerModels_SourceFilesToProcess) {
    declare Index = LibPlayerModels_SourceFilesOrder.keyof(Url);

    SortedSourceFiles[Index] = Url;
  }

  SortedSourceFiles = SortedSourceFiles.sortkey();

  // Used exclusively for the display naming convention.
  declare NbCharacters = 0;
  declare NbVehicles = 0;

  declare Text[Text] LibPlayerModels_ModelIdBySkinDirectory for LoadedTitle;

  // Source files are iterated two separate times, and that is intended.
  // We want to be absolutely sure that all base models are loaded before everything else.
  foreach (Url in SortedSourceFiles) {
    declare SourceFile = LibPlayerModels_SourceFilesToProcess[Url];
    declare BaseUrl = Private_GetBaseUrl(Url);

    foreach (Model in SourceFile.Models) {
      if (Model.Id == "") {
        continue;
      }

      foreach (SkinDirectory in Model.SkinDirectories) {
        LibPlayerModels_ModelIdBySkinDirectory[SkinDirectory^"\\"] = Model.Id;
      }

      Private_AppendModel(Model, BaseUrl);

      if (Private_IsCharacter(Model.Archetype)) {
        NbCharacters += 1;
      } else {
        NbVehicles += 1;
      }
    }
  }

  // Reverse sorting allows the deepest subfolders to be checked first.
  LibPlayerModels_ModelIdBySkinDirectory = LibPlayerModels_ModelIdBySkinDirectory.sortkeyreverse();

  declare K_Model[Text] LibPlayerModels_ModelById for LoadedTitle;
  declare K_Skin[Text] LibPlayerModels_SkinById for LoadedTitle;
  declare K_Overlay[Text] LibPlayerModels_OverlayById for LoadedTitle;

  // Append skins and overlays.
  foreach (Url in SortedSourceFiles) {
    declare SourceFile = LibPlayerModels_SourceFilesToProcess[Url];
    declare BaseUrl = Private_GetBaseUrl(Url);

    foreach (Skin in SourceFile.Skins) {
      if (Skin.Id == "" || (!LibPlayerModels_ModelById.existskey(Skin.AppliesTo) && Skin.Id != C_LibPlayerModels_CarCommonWildcard)) {
        continue;
      }

      Private_AppendSkin(Skin, BaseUrl);
    }

    foreach (Overlay in SourceFile.Overlays) {
      if (Overlay.Id == "" || !LibPlayerModels_ModelById.existskey(Overlay.Extends)) {
        continue;
      }

      Private_AppendOverlay(Overlay, BaseUrl);
    }
  }

  LibPlayerModels_SourceFilesToProcess.clear();

  declare Text[] LibPlayerModels_SkinPathsToProcess for LoadedTitle;

  // Creates dummy skin entries from the user Skins directory files.
  // TODO: User skins should be a separate, dynamically-changing list.
  foreach (File in LibPlayerModels_SkinPathsToProcess) {
    declare Skin = Private_CreateSkinFromPath(File);

    if (Skin.Id == "") {
      continue;
    }

    Private_AppendSkin(Skin, "");
  }

  LibPlayerModels_SkinPathsToProcess.clear();

  // Create aliases.
  Private_CreateModelAliases(LibPlayerModels_ModelById);
  Private_CreateOverlayAliases(LibPlayerModels_OverlayById);

  // Get the metrics.
  declare NbModels = LibPlayerModels_ModelById.count;
  declare NbSkins = LibPlayerModels_SkinById.count;
  declare NbOverlays = LibPlayerModels_OverlayById.count;
  declare LoadTime = Now - LibPlayerModels_LoadingStartTime;

  LibPlayerModels_LoadingStartTime = -1;

  // Apply the correct naming convention, depending on the loaded model types.
  declare Text LibPlayerModels_ModelTypeCategory for LoadedTitle;

  if (NbModels == NbCharacters) {
    LibPlayerModels_ModelTypeCategory = C_LibPlayerModels_ModelType_Character;
  }

  if (NbModels == NbVehicles) {
    LibPlayerModels_ModelTypeCategory = C_LibPlayerModels_ModelType_Vehicle;
  }

  Private_Log("""Loaded data of {{{NbModels}}} models, {{{NbSkins}}} skins, {{{NbOverlays}}} overlays in {{{LoadTime}}} ms""");
}

/**
 * Clear all the cached data.
 */
Void Private_ClearData() {
  declare Integer LibPlayerModels_LoadingStartTime for LoadedTitle;
  declare K_Options LibPlayerModels_Options for LoadedTitle;
  declare Text[] LibPlayerModels_SortingOverrides for LoadedTitle;
  declare K_Model[Text] LibPlayerModels_ModelById for LoadedTitle;
  declare K_Skin[Text] LibPlayerModels_SkinById for LoadedTitle;
  declare K_Overlay[Text] LibPlayerModels_OverlayById for LoadedTitle;
  declare Text[Text] LibPlayerModels_ModelIdBySkinDirectory for LoadedTitle;
  declare Text[Text] LibPlayerModels_ModelIdByAlias for LoadedTitle;

  LibPlayerModels_LoadingStartTime = -1;
  LibPlayerModels_Options = K_Options {};
  LibPlayerModels_SortingOverrides.clear();
  LibPlayerModels_OverlayById.clear();
  LibPlayerModels_ModelById.clear();
  LibPlayerModels_SkinById.clear();
  LibPlayerModels_ModelIdByAlias.clear();
  LibPlayerModels_ModelIdBySkinDirectory.clear();
}

/**
 * Start loading data with the given options.
 */
Void Private_StartLoading(K_Options _Options) {
  declare Options = _Options;

  if (Options.IndexFileUrl == "") {
    Options.IndexFileUrl = C_LibPlayerModels_DefaultIndexFileUrl;
  }

  if (!HttpClient::IsValidUrl(Options.IndexFileUrl)) {
    return;
  }

  Private_ClearData();

  declare Integer LibPlayerModels_LoadingStartTime for LoadedTitle;
  declare K_Options LibPlayerModels_Options for LoadedTitle;

  LibPlayerModels_LoadingStartTime = Now;
  LibPlayerModels_Options = Options;

  HttpClient::Get(C_LibPlayerModels_EventId_GetIndexFile, LibPlayerModels_Options.IndexFileUrl);

  if (!LibPlayerModels_Options.LoadUserSkinsDirectory || DataFileMgr == Null) {
    return;
  }

  declare CTaskResult_FileList[Ident] G_LibPlayerModels_PendingTasks for LoadedTitle;

  foreach (Directory in C_LibPlayerModels_UserSkinsDirectories) {
    declare Task <=> Private_CreateUserDataTask(Directory);

    G_LibPlayerModels_PendingTasks[Task.Id] = Task;
  }
}

// ---------------------------------- //
// Public functions
// ---------------------------------- //

Void Unload() {
  foreach (TaskId => __ in G_LibPlayerModels_PendingTasks) {
    DataFileMgr.TaskResult_Release(TaskId);
  }

  G_LibPlayerModels_PendingTasks.clear();
}

/**
 * Starts loading the data from the index file, if necessary.
 *
 * You should do a `while (Loading()) MB_Yield();` loop right after calling Load().
 */
Void Load(K_Options _Options) {
  Unload();

  declare Integer LibPlayerModels_LoadingStartTime for LoadedTitle;
  declare K_Options LibPlayerModels_Options for LoadedTitle;

  // Don't wait for the previously fired loading if it takes too long.
  if (LibPlayerModels_LoadingStartTime > 0 && Now - LibPlayerModels_LoadingStartTime > C_LibPlayerModels_DataLoadingTimeout) {
    LibPlayerModels_LoadingStartTime = -1;
  }

  if (LibPlayerModels_LoadingStartTime <= 0 && LibPlayerModels_Options.IndexFileUrl == "") {
    Private_StartLoading(_Options);
  }
}

Void Load() {
  Load(K_Options {});
}

/**
 * @returns True while data is being loaded.
 */
Boolean Loading() {
  // Must call outside of the OR operator for all the loops to execute concurrently.
  declare IsLoadingHttp = Private_LoadingHttpRequests();
  declare IsLoadingTasks = Private_LoadingTaskResults();

  declare IsLoading = IsLoadingHttp || IsLoadingTasks;

  if (!IsLoading) {
    Private_FinalizeSourceFiles();
  }

  declare Integer LibPlayerModels_LoadingStartTime for LoadedTitle;

  return LibPlayerModels_LoadingStartTime > 0 || IsLoading;
}

/**
 * @returns "Characters", "Vehicles" or "" for empty or mixed model types.
 */
Text ModelTypeCategory() {
  declare Text LibPlayerModels_ModelTypeCategory for LoadedTitle;

  return LibPlayerModels_ModelTypeCategory;
}

/**
 * @returns Custom model id resolved from the item path.
 * @example `Vehicles/IslandCar.Item.Gbx` -> `trackmania:islandcar`
 */
Text ResolveModelId(Text _ItemPath) {
  declare K_Model[Text] LibPlayerModels_ModelById for LoadedTitle;

  // Direct model hit!
  if (LibPlayerModels_ModelById.existskey(_ItemPath)) {
    return _ItemPath;
  }

  declare K_Overlay[Text] LibPlayerModels_OverlayById for LoadedTitle;

  // Direct overlay hit!
  if (LibPlayerModels_OverlayById.existskey(_ItemPath)) {
    return _ItemPath;
  }

  // Find case-insensitive alias.
  declare Text[Text] LibPlayerModels_ModelIdByAlias for LoadedTitle;
  declare ItemPath = TL::ToLowerCase(_ItemPath);

  if (LibPlayerModels_ModelIdByAlias.existskey(ItemPath)) {
    return LibPlayerModels_ModelIdByAlias[ItemPath];
  }

  // Desperately try to match some loaded item.
  declare NormalizedItemPath = Private_NormalizeItemPath(ItemPath);

  if (LibPlayerModels_ModelIdByAlias.existskey(NormalizedItemPath)) {
    return LibPlayerModels_ModelIdByAlias[NormalizedItemPath];
  }

  return "";
}

/**
 * @returns Base custom model id of the gameplay extension, or the custom model id itself.
 */
Text GetBaseModelId(Text _ModelId) {
  declare K_Overlay[Text] LibPlayerModels_OverlayById for LoadedTitle;

  if (LibPlayerModels_OverlayById.existskey(_ModelId)) {
    return LibPlayerModels_OverlayById[_ModelId].Extends;
  }

  declare K_Model[Text] LibPlayerModels_ModelById for LoadedTitle;

  if (LibPlayerModels_ModelById.existskey(_ModelId)) {
    return _ModelId;
  }

  return "";
}

K_Model[Text] GetAllModels() {
  declare K_Model[Text] LibPlayerModels_ModelById for LoadedTitle;

  return LibPlayerModels_ModelById;
}

K_Skin[Text] GetAllSkins() {
  declare K_Skin[Text] LibPlayerModels_SkinById for LoadedTitle;

  return LibPlayerModels_SkinById;
}

K_Overlay[Text] GetAllOverlays() {
  declare K_Overlay[Text] LibPlayerModels_OverlayById for LoadedTitle;

  return LibPlayerModels_OverlayById;
}

K_Model[] GetModelsList(Boolean _IncludeHidden) {
  declare K_Model[Text] LibPlayerModels_ModelById for LoadedTitle;
  declare Text[] LibPlayerModels_SortingOverrides for LoadedTitle;

  declare Text[] SortedModelIds;

  foreach (ModelId in LibPlayerModels_SortingOverrides) {
    if (LibPlayerModels_ModelById.existskey(ModelId)) {
      SortedModelIds.add(ModelId);
    }
  }

  foreach (ModelId => __ in LibPlayerModels_ModelById) {
    if (!SortedModelIds.exists(ModelId)) {
      SortedModelIds.add(ModelId);
    }
  }

  declare K_Model[] Result;

  foreach (ModelId in SortedModelIds) {
    if (!LibPlayerModels_ModelById.existskey(ModelId)) {
      continue;
    }

    declare Model = LibPlayerModels_ModelById[ModelId];

    if (!_IncludeHidden && Model.IsHidden) {
      continue;
    }

    Result.add(Model);
  }

  return Result;
}

K_Model[] GetModelsList() {
  return GetModelsList(False);
}

K_Skin[] GetSkinsListByModelId(Text _ModelId, Boolean _IncludeHidden) {
  declare BaseModelId = GetBaseModelId(_ModelId);
  declare K_Skin[] Result;

  declare K_Skin[Text] LibPlayerModels_SkinById for LoadedTitle;

  foreach (Skin in LibPlayerModels_SkinById) {
    if (Skin.AppliesTo != BaseModelId && Skin.AppliesTo != C_LibPlayerModels_CarCommonWildcard) {
      continue;
    }

    if (!_IncludeHidden && Skin.IsHidden) {
      continue;
    }

    Result.add(Skin);
  }

  return Result;
}

K_Skin[] GetSkinsListByModelId(Text _ModelId) {
  return GetSkinsListByModelId(_ModelId, False);
}

Text GetRandomSkinIdByModelId(Text _ModelId, Boolean _IncludeHidden) {
  declare Skins = GetSkinsListByModelId(_ModelId, _IncludeHidden);

  if (Skins.count <= 0) {
    return "";
  }

  if (Skins.count == 1) {
    return Skins[0].Id;
  }

  declare Index = ML::Rand(0, Skins.count - 1);

  return Skins[Index].Id;
}

Text GetRandomSkinIdByModelId(Text _ModelId) {
  return GetRandomSkinIdByModelId(_ModelId, False);
}

Text GetModelArchetype(Text _ModelId) {
  declare BaseModelId = GetBaseModelId(_ModelId);

  declare K_Model[Text] LibPlayerModels_ModelById for LoadedTitle;

  if (LibPlayerModels_ModelById.existskey(_ModelId)) {
    return LibPlayerModels_ModelById[_ModelId].Archetype;
  }

  return "";
}

Boolean GetArchetypeIsUnitedVehicle(Text _Archetype) {
  return C_LibPlayerModels_TMUnitedArchetypes.exists(_Archetype);
}

Boolean GetPlayerModelIsUnitedVehicle(Text _ModelId) {
  return GetArchetypeIsUnitedVehicle(GetModelArchetype(_ModelId));
}

K_GameplayInfo GetPlayerModelGameplayInfo(Text _ModelId) {
  declare DefaultResult = K_GameplayInfo {
    AccelCoef = 1.0,
    ControlCoef = 1.0,
    GravityCoef = 1.0
  };

  declare K_Overlay[Text] LibPlayerModels_OverlayById for LoadedTitle;

  if (!LibPlayerModels_OverlayById.existskey(_ModelId)) {
    return DefaultResult;
  }

  declare GameplayInfo = LibPlayerModels_OverlayById[_ModelId].Gameplay;

  if (GameplayInfo.AccelCoef != 0.0 || GameplayInfo.ControlCoef != 0.0 || GameplayInfo.GravityCoef != 0.0) {
    return GameplayInfo;
  }

  return DefaultResult;
}

Text GetPlayerModelAsset(Text _ModelId, Text _AssetId, Text _Fallback) {
  declare K_Model[Text] LibPlayerModels_ModelById for LoadedTitle;

  if (LibPlayerModels_ModelById.existskey(_ModelId)) {
    if (LibPlayerModels_ModelById[_ModelId].Assets.existskey(_AssetId)) {
      return LibPlayerModels_ModelById[_ModelId].Assets[_AssetId];
    }

    return _Fallback;
  }

  // Fallback to overlay.
  declare K_Overlay[Text] LibPlayerModels_OverlayById for LoadedTitle;

  if (!LibPlayerModels_OverlayById.existskey(_ModelId)) {
    return _Fallback;
  }

  if (LibPlayerModels_OverlayById[_ModelId].Assets.existskey(_AssetId)) {
    return LibPlayerModels_OverlayById[_ModelId].Assets[_AssetId];
  }

  // Fallback to overlay base model.
  return GetPlayerModelAsset(LibPlayerModels_OverlayById[_ModelId].Extends, _AssetId, _Fallback);
}

Text GetSkinAsset(Text _SkinId, Text _AssetId, Text _Fallback) {
  declare K_Skin[Text] LibPlayerModels_SkinById for LoadedTitle;

  if (!LibPlayerModels_SkinById.existskey(_SkinId)) return _Fallback;

  if (LibPlayerModels_SkinById[_SkinId].Assets.existskey(_AssetId)) {
    return LibPlayerModels_SkinById[_SkinId].Assets[_AssetId];
  }

  // Fallback to model.
  return GetPlayerModelAsset(LibPlayerModels_SkinById[_SkinId].AppliesTo, _AssetId, _Fallback);
}
