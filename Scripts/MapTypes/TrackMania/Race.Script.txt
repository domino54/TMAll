/**
 * Standard Trackmania race map type.
 *
 * @name Race.Script.txt
 * @author domino54
 * @version 2024-10-18
 */

#Extends "MapTypes/Base/MapTypeTMAll.Script.txt"

#Const Version    "2024-10-18"
#Const ScriptName "MapTypes/TrackMania/Race.Script.txt"

#Include "Libs/Nadeo/Common/Ingame/MapType.Script.txt" as MapType
#Include "Libs/Nadeo/MP4/TitlePackMaker/MapEditor/UI/Validation.Script.txt" as UI_Validation
#Include "Libs/Trackmania/Ingame/Game.Script.txt" as Game

// ---------------------------------- //
// Global variables
// ---------------------------------- //

declare Integer G_BestTime;
declare Integer[] G_BestCheckpointsTimes;
declare CGhost G_BestPlayerGhost;

// ---------------------------------- //
// Log versions
// ---------------------------------- //
***MTB_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(Game::ScriptName, Game::Version);
Log::RegisterScript(MapType::ScriptName, MapType::Version);
Log::RegisterScript(UI_Validation::ScriptName, UI_Validation::Version);
***

// ---------------------------------- //
// Update validability
// ---------------------------------- //
***MTB_UpdateValidability***
***
declare StartsFinishes = 0;
declare Starts = 0;
declare Finishes = 0;
declare Checkpoints = 0;

foreach (Anchor in AnchorData) {
  switch (Anchor.WaypointType) {
    case CAnchorData::EWaypointType::StartFinish: StartsFinishes += 1;
    case CAnchorData::EWaypointType::Start: Starts += 1;
    case CAnchorData::EWaypointType::Finish: Finishes += 1;
    case CAnchorData::EWaypointType::Checkpoint: Checkpoints += 1;
  }
}

// It's a multilap
if (StartsFinishes > 0) {
  // No start line block, so there must be exactly one multilap block, so that we know where the car will spawn.
  if (Starts == 0 && StartsFinishes > 1) {
    //L16N [MapEditor] Message explaining to the player that a track can contain only one start line block.
    ValidabilityRequirementsMessage = _("You can place only one starting point!");
    return CMapType::ValidationStatus::NotValidable;
  }
  // A start line block may be present: in that case the car will spawn on it, and not on the multilap block.
  // But there must be only one start line block (and there could be more than one multilap block).
  if (Starts > 1) {
    //L16N [MapEditor] Message explaining to the player that a track can contain only one start line block.
    ValidabilityRequirementsMessage = _("You can place only one starting point!");
    return CMapType::ValidationStatus::NotValidable;
  }
  // Has at least one checkpoint
  if (Checkpoints < 1) {
    //L16N [MapEditor] Message explaining to the player that a track has to contain at least one checkpoint block.
    ValidabilityRequirementsMessage = _("You must place at least one checkpoint!");
    return CMapType::ValidationStatus::NotValidable;
  }
}
// It's a simple race
else {
  // Exactly one start
  if (Starts != 1) {
    //L16N [MapEditor] Message explaining to the player that a track has to contain exactly one start line block.
    ValidabilityRequirementsMessage = _("You need to place a starting point!");
    return CMapType::ValidationStatus::NotValidable;
  }
  // At least one finish
  if (Finishes < 1) {
    //L16N [MapEditor] Message explaining to the player that a track has to contain exactly one finish line block.
    ValidabilityRequirementsMessage = _("You must place at least one finish line!");
    return CMapType::ValidationStatus::NotValidable;
  }
}

// If the objectives times are not valid, the author must revalidate their map.
if (!MapType::ObjectivesAreValid()) {
  return CMapType::ValidationStatus::Validable;
}

// Allow to start the validation.
if (ValidationStatus == CMapType::ValidationStatus::NotValidable) {
  return CMapType::ValidationStatus::Validable;
}
***

// ---------------------------------- //
// Edit objectives
// ---------------------------------- //
***MTB_EditObjectives***
***
DisplayDefaultSetObjectivesDialog();
***

// ---------------------------------- //
// Reset objectives
// ---------------------------------- //
***MTB_ResetObjectives***
***
MapType::ResetObjectives();
***

// ---------------------------------- //
// Init validation
// ---------------------------------- //
***Validation_Init***
***
ValidationEndNoConfirm = False;
Player.Score.Clear();
TM_StartRace(Player, -1);
***

// ---------------------------------- //
// Start validation
// ---------------------------------- //
***Validation_Start***
***
InitUIIngame();

Mode.CutOffTimeLimit = -1;
G_BestTime = Map.TMObjective_AuthorTime;

UI_Validation::Load(True);
UI_Validation::SetTime(G_BestTime, -1);

TM_StartRace(Player, Mode.Now + Game::GetSpawnDuration());

Game::SetKeepPlayersSpawned(True);
***

// ---------------------------------- //
// Validation loop
// ---------------------------------- //
***Validation_PlayLoop***
***
Game::Loop();

if (Player.RaceStartTime <= 0 && Game::IsWaiting(Player)) {
  +++TMPlayground_StartRace+++

  InitUIIngame();
  Game::StartRace(Player, Mode.Now + Game::GetSpawnDuration(), False);

  if (G_BestCheckpointsTimes.count > 0) {
    Game::SetOpponent(0, G_BestCheckpointsTimes);
  }

  if (G_BestPlayerGhost != Null) {
    Mode.RaceGhost_RemoveAll();
    Mode.RaceGhost_Add(G_BestPlayerGhost, True);
  }
}

// Events
foreach (Event in Mode.PendingEvents) {
  Mode.PassOn(Event);

  if (Event.Type != CTmModeEvent::EType::WayPoint || !Event.IsEndRace) {
    continue;
  }

  Game::EndRace(Player);

  if (Event.Player.Score.BestRace.Compare(Event.Player.CurRace, CTmResult::ETmRaceResultCriteria::Time) <= 0) {
    Event.Player.Score.BestRace = Event.Player.CurRace;
  }

  Event.Player.Score.PrevRace = Event.Player.CurRace;

  declare PlayerTime = Event.Player.Score.PrevRace.Time;
  declare Integer[] PlayerCheckpointsTimes;

  UI_Validation::SetTime(G_BestTime, PlayerTime);

  if (G_BestTime <= 0 && Event.Player.CurRace.Time > 0) {
    G_BestTime = Event.Player.CurRace.Time;
    PlayerCheckpointsTimes = CopyCheckpoints(Event.Player.CurRace);
  }
  else if (Event.Player.Score.BestRace != Null && Event.Player.Score.BestRace.Time > 0 && Event.Player.Score.BestRace.Time < G_BestTime) {
    G_BestTime = Event.Player.Score.BestRace.Time;
    PlayerCheckpointsTimes = CopyCheckpoints(Event.Player.Score.BestRace);
  }

  // Update checkpoints times
  if (G_BestTime > 0 && PlayerCheckpointsTimes.count > 0 && (Map.TMObjective_AuthorTime <= 0 || G_BestTime < Map.TMObjective_AuthorTime)) {
    G_BestCheckpointsTimes = PlayerCheckpointsTimes;
    G_BestPlayerGhost = Mode.ScoreMgr.Playground_GetPlayerGhost(Player);
  }

  // Try again?
  declare PrevAnswerUpdate = UI_Validation::GetAnswerUpdate();

  UI_Validation::Show();

  Audio.LimitSceneSoundVolumedB = -1000.0;
  Mode.UIManager.UIAll.UISequence = CUIConfig::EUISequence::UIInteraction;

  while (True) {
    MTB_Yield();

    foreach (Event in Mode.PendingEvents) {
      Mode.Discard(Event);
    }

    if (PrevAnswerUpdate != UI_Validation::GetAnswerUpdate()) {
      declare StopValidation = UI_Validation::GetAnswer();

      if (StopValidation)  {
        MTB_StopValidation();
      } else {
        Game::WaitRace(Player);
      }

      break;
    }
  }

  UI_Validation::SetTime(G_BestTime, PlayerTime);
  UI_Validation::Hide();

  Audio.LimitSceneSoundVolumedB = 0.0;
  Mode.UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
}
***

// ---------------------------------- //
// Validation end
// ---------------------------------- //
***Validation_End***
***
Game::WaitRace(Player);
Game::Unload();

UI_Validation::Unload();

// New best author time, save it.
if (G_BestTime > 0 && (Map.TMObjective_AuthorTime <= 0 || G_BestTime < Map.TMObjective_AuthorTime)) {
  MapType::SetObjectivesFromAuthorTime(G_BestTime);
}

if (Map.TMObjective_AuthorTime > 0) {
  ValidationStatus = CMapType::ValidationStatus::Validated;
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

/**
 * Initializes the game UI.
 */
Void InitUIIngame() {
  Game::Load(Mode, "Trackbuilder");
  Game::SetNbLaps(Map.TMObjective_NbLaps, Map.TMObjective_IsLapRace);
}

/**
 * Copy the checkpoints times into an array.
 *
 * @param _Result The result from where the checkpoints times are extracted.
 * @return The checkpoints times.
 */
Integer[] CopyCheckpoints(CTmResult _Result) {
  if (_Result == Null) {
    return [];
  }

  declare Integer[] CheckpointsTimes;
  foreach (Time in _Result.Checkpoints) {
    CheckpointsTimes.add(Time);
  }
  return CheckpointsTimes;
}
